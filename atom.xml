<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拍拍贷基础框架团队博客</title>
  
  <subtitle>致力于成为互联网行业一流的框架技术团队</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://techblog.ppdai.com/"/>
  <updated>2018-07-02T13:40:02.260Z</updated>
  <id>http://techblog.ppdai.com/</id>
  
  <author>
    <name>基础框架</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍</title>
    <link href="http://techblog.ppdai.com/2018/06/28/2018062804/"/>
    <id>http://techblog.ppdai.com/2018/06/28/2018062804/</id>
    <published>2018-06-28T13:02:35.000Z</published>
    <updated>2018-07-02T13:40:02.260Z</updated>
    
    <content type="html"><![CDATA[<p>Jedis源码分析共有四个章节，以下为各章链接：</p><ol><li><a href="/2018/06/28/2018062801/">Jedis源码分析(一) - Jedis介绍</a></li><li><a href="/2018/06/28/2018062802/">Jedis源码分析(二) - Jedis类结构及实现</a></li><li><a href="/2018/06/28/2018062803/">Jedis源码分析(三) - JedisCluster类结构及实现</a></li><li><a href="/2018/06/28/2018062804/">Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍</a></li></ol><a id="more"></a><h3 id="JedisSentinel"><a href="#JedisSentinel" class="headerlink" title="JedisSentinel"></a>JedisSentinel</h3><p>JedisSentinel常用方式有两种：</p><p>1.使用哨兵单节点拿到主节点，从节点的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过哨兵节点的信息新建Jedis实例，然后拿到Master节点的信息</span></span><br><span class="line">Jedis j = <span class="keyword">new</span> Jedis(sentinel);</span><br><span class="line">List&lt;Map&lt;String, String&gt;&gt; masters = j.sentinelMasters();</span><br><span class="line"><span class="comment">//拿到master的address，**MASTER_NAME**</span></span><br><span class="line">List&lt;String&gt; masterHostAndPort = j.sentinelGetMasterAddrByName(**MASTER_NAME**);</span><br><span class="line">HostAndPort masterFromSentinel = <span class="keyword">new</span> HostAndPort(masterHostAndPort.get(<span class="number">0</span>),Integer.parseInt(masterHostAndPort.get(<span class="number">1</span>)));</span><br><span class="line">assertEquals(master, masterFromSentinel);</span><br><span class="line"><span class="comment">//通过哨兵节点，拿到从节点的信息</span></span><br><span class="line">List&lt;Map&lt;String, String&gt;&gt; slaves = j.sentinelSlaves(**MASTER_NAME**);</span><br></pre></td></tr></table></figure><p>2.使用哨兵节点对象池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"localhost"</span>, <span class="number">65432</span>).toString());</span><br><span class="line">sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"localhost"</span>, <span class="number">65431</span>).toString());</span><br><span class="line">JedisSentinelPool pool = <span class="keyword">new</span> JedisSentinelPool(MASTER_NAME, sentinels);</span><br><span class="line">pool.destroy();</span><br></pre></td></tr></table></figure><p><code>JedisSentinelPool</code>的结构清晰，内部使用对象池存放一个个<code>sentinel</code>实例。图2-12和2-13分别为<code>JedisSentinelPool</code>的类结构和初始化流程。在使用时，我们先根据，host,port等信息，初始化一个Jedis实例，然后可以通过<code>sentinelMasters()</code>，<code>sentinelGetMasterAddrByName(MASTER_NAME)</code>，<code>sentinelSlaves(MASTER_NAME)</code>等方法拿到这个哨兵节点监听的MASTER节点信息或对应的SLAVE节点信息。</p><p><img src="/2018/06/28/2018062804/image014.png" alt="image014"></p><center style="margin: -20px 0 20px">图1.1 JedisSentinelPool 的类结构</center><p><img src="/2018/06/28/2018062804/image015.png" alt="image015"></p><center style="margin: -20px 0 20px">图1.2 JedisSentinelPool 的初始化流程</center><h3 id="ShardedJedis"><a href="#ShardedJedis" class="headerlink" title="ShardedJedis"></a>ShardedJedis</h3><p>下文为构建Jedis分片的方法（单节点与对象池的模式），</p><p>1.单节点模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;JedisShardInfo&gt; shards = <span class="keyword">new</span> ArrayList&lt;JedisShardInfo&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//其中一个分片</span></span><br><span class="line">JedisShardInfo shard1 = <span class="keyword">new</span> JedisShardInfo(redis1);</span><br><span class="line">shards.add(shard1);</span><br><span class="line"><span class="comment">//另一个分片</span></span><br><span class="line">JedisShardInfo shard2 = <span class="keyword">new</span> JedisShardInfo(redis2);</span><br><span class="line">shards.add(shard2);</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="comment">//新建ShardedJedis实例</span></span><br><span class="line">ShardedJedis shardedJedis = <span class="keyword">new</span> ShardedJedis(shards);</span><br><span class="line">shardedJedis.set(<span class="string">"a"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="comment">//通过key可以查看存储在哪个jedis</span></span><br><span class="line">JedisShardInfo ak = shardedJedis.getShardInfo(<span class="string">"a"</span>);</span><br><span class="line">assertEquals(shard2, ak);</span><br></pre></td></tr></table></figure><p>2.对象池模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ShardedJedisPool pool = <span class="keyword">new</span> ShardedJedisPool(<span class="keyword">new</span> GenericObjectPoolConfig(), shards);</span><br><span class="line">ShardedJedis jedis = pool.getResource();</span><br><span class="line">jedis.set(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">assertEquals(<span class="string">"bar"</span>, jedis.get(<span class="string">"foo"</span>));</span><br></pre></td></tr></table></figure><p><img src="/2018/06/28/2018062804/image016.png" alt="image016"></p><center style="margin: -20px 0 20px">图2-1 ShardedJedis的类结构</center><p><img src="/2018/06/28/2018062804/image017.png" alt="image017"></p><center style="margin: -20px 0 20px">图2-1 ShardedJedis的初始化流程</center><p>图2-1为ShardedJedis的类结构（其内部保存一个对象池，与常规的JedisPool的不同之处在于，内部的<code>PooledObjectFactory</code>实现不同）,分片信息保存在基类<code>Sharded</code>中，<code>Sharded</code>保存了3个重要变量：</p><ol><li>nodes是一个TreeMap,保存了每个分片节点和对应的hash值。</li><li>algo是计算hash值的函数，默认是MurmurHash,可替换。</li><li>resources是一个LinkedHashMap，存放着JedisShardinfo和一个Jedis实例的对应关系。</li></ol><p>图2-2为 <code>ShardedJedis</code>的初始化流程，通过传入待分片的节点信息，初始化好上述3个变量。在使用时，先根据key计算出hash值，在<code>nodes</code>中找到对应的分片信息，再在<code>resources</code>中找到对应的Jedis实例，然后通过这个Jedis实例才操作redis节点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jedis源码分析共有四个章节，以下为各章链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062801/&quot;&gt;Jedis源码分析(一) - Jedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062802/&quot;&gt;Jedis源码分析(二) - Jedis类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062803/&quot;&gt;Jedis源码分析(三) - JedisCluster类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062804/&quot;&gt;Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Jedis" scheme="http://techblog.ppdai.com/tags/Jedis/"/>
    
  </entry>
  
  <entry>
    <title>Jedis源码分析(三) - JedisCluster类结构及实现</title>
    <link href="http://techblog.ppdai.com/2018/06/28/2018062803/"/>
    <id>http://techblog.ppdai.com/2018/06/28/2018062803/</id>
    <published>2018-06-28T12:42:20.000Z</published>
    <updated>2018-07-02T13:40:10.621Z</updated>
    
    <content type="html"><![CDATA[<p>Jedis源码分析共有四个章节，以下为各章链接：</p><ol><li><a href="/2018/06/28/2018062801/">Jedis源码分析(一) - Jedis介绍</a></li><li><a href="/2018/06/28/2018062802/">Jedis源码分析(二) - Jedis类结构及实现</a></li><li><a href="/2018/06/28/2018062803/">Jedis源码分析(三) - JedisCluster类结构及实现</a></li><li><a href="/2018/06/28/2018062804/">Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍</a></li></ol><a id="more"></a><h2 id="JedisCluster的内部结构"><a href="#JedisCluster的内部结构" class="headerlink" title="JedisCluster的内部结构"></a>JedisCluster的内部结构</h2><p>首先看一下JedisCluster的类结构，为橘色标志为核心类</p><p><img src="/2018/06/28/2018062803/image009.png" alt="avatar"></p><center style="margin: -20px 0 20px">图1 JedisCluster的类结构</center><p>图1是JedisCluster的类结构，由于Jedis本身不是线程安全的，所以选择使用对象池JedisPool 来保证线程安全。在<code>JedisClusterInfoCache</code>中，除了要保存节点和槽的一一对应关系，还要为每个节点建立一个对象池<code>JedisPool</code>，并保存在<code>map</code>中。因而，这个类主要用于保存集群的配置信息，并且是JedisCluster初始化部分的核心所在。<code>JedisClusterConnectionHandler</code>是cache类的一个窗口，cache类似数据管理层，而Handler就类似于操控数据提供服务的Service层。</p><h2 id="JedisCluster的初始化"><a href="#JedisCluster的初始化" class="headerlink" title="JedisCluster的初始化"></a>JedisCluster的初始化</h2><p><img src="/2018/06/28/2018062803/image010.jpg" alt="avatar"></p><center style="margin: -20px 0 20px">图2-1 JedisCluster初始化调用时序图</center><p><img src="/2018/06/28/2018062803/image011.jpg" alt="avatar"></p><center style="margin: -20px 0 20px">图2-2 JedisCluster的初始化详情</center><p>图2-1，2-2是JedisCluster初始化的具体实现。Jedis建立集群的过程很清晰，传入节点信息，通过其中一个节点从redis服务器拿到整个集群的信息信息，包括槽位对应关系，主从节点的信息，保存在JedisClusterInfoCache中。</p><h2 id="JedisCluster的调用流程"><a href="#JedisCluster的调用流程" class="headerlink" title="JedisCluster的调用流程"></a>JedisCluster的调用流程</h2><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;HostAndPort&gt; jedisClusterNode = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7379</span>));</span><br><span class="line">JedisCluster jc = <span class="keyword">new</span> JedisCluster(jedisClusterNode, DEFAULT_TIMEOUT, DEFAULT_TIMEOUT,</span><br><span class="line">    DEFAULT_REDIRECTIONS, <span class="string">"cluster"</span>, DEFAULT_CONFIG);</span><br><span class="line">jc.set(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">assertEquals(<span class="string">"bar"</span>, jc.get(<span class="string">"foo"</span>));</span><br></pre></td></tr></table></figure><p><img src="/2018/06/28/2018062803/image012.jpg" alt="avatar">                  </p><center style="margin: -20px 0 20px">图3-1 JedisCluster 命令时序图</center><p><img src="/2018/06/28/2018062803/image013.jpg" alt="avatar"></p><center style="margin: -20px 0 20px">图3-2 JedisCluster 命令调用的具体实现过程</center><p>图3-1，3-2是JedisCluster发送请求的具体实现。在发送请求时，JedisCluster对象先从初始化得到的集群map中获取key对应的节点连接，即一个可用的Jedis对象。然后通过这个对象发送<code>get key</code> 命令。</p><p>通常，根据key计算槽位得到的节点不会报错。所以如果发生<code>connectionException</code>,或者<code>MovedDataException</code>,说明初始化得到的槽位与节点的对应关系有问题，即与实际的对应关系不符，应当重置map。</p><p>如果出现ASK异常，说明数据正在迁移，需要临时使用返回消息指定的地址，重新发送命令。在这里，Jedis通过异常反馈，智能地同步了客户端与服务端的集群信息。</p><h2 id="Jedis与Redis的版本冲突"><a href="#Jedis与Redis的版本冲突" class="headerlink" title="Jedis与Redis的版本冲突"></a>Jedis与Redis的版本冲突</h2><p>在之前的代码分析中，源码均来自于<strong>Jedis-2.10</strong>，下面我们来看下<strong>Jedis-2.7.3</strong>中<code>cache.discoverClusterNodesAndSlots</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JedisClusterInfoCache类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discoverClusterNodesAndSlots</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"><span class="comment">//清空两个map</span></span><br><span class="line">    <span class="keyword">this</span>.nodes.clear();</span><br><span class="line">    <span class="keyword">this</span>.slots.clear();</span><br><span class="line">    <span class="comment">//获取集群信息</span></span><br><span class="line">    String localNodes = jedis.clusterNodes();</span><br><span class="line">    <span class="keyword">for</span> (String nodeInfo : localNodes.split(<span class="string">"\n"</span>)) &#123;</span><br><span class="line"><span class="comment">//这个方法处理“cluster nodes”命令的回复消息，先通过” ”分割消息，再通过“：”分割得到“host”和”port”。</span></span><br><span class="line">        ClusterNodeInformation clusterNodeInfo = </span><br><span class="line">            nodeInfoParser.parse(nodeInfo, <span class="keyword">new</span> HostAndPort(</span><br><span class="line">            jedis.getClient().getHost(), jedis.getClient().getPort()));</span><br><span class="line">        HostAndPort targetNode = clusterNodeInfo.getNode();</span><br><span class="line">        setNodeIfNotExist(targetNode);</span><br><span class="line">        assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出与<strong>Jedis-2.10</strong>不同的是，这里使用<code>CLUSTER NODES</code>获取集群信息。</p><p>这是<strong>Redis-3.2.9</strong>对于<code>CLUSTER NODES</code>命令的回复消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">860abdabe239d096cff13385382325784ad601fc 127.0.0.1:6568 myself,master - 0 0 4 connected 5462-10923</span><br><span class="line">24e8ebefc4d0eaefd6950d30bc389e50aab84286 127.0.0.1:6394 slave 860abdabe239d096cff13385382325784ad601fc 0 1516623794886 4 connected</span><br><span class="line">d27c2ce7de4029b4f2828d67cf45e82211b1369c 127.0.0.1:6569 slave 8f82154da33324208e79bdb9580cea2ca0cada93 0 1516623795905 2 connected</span><br><span class="line">8f82154da33324208e79bdb9580cea2ca0cada93  127.0.0.1:6395 master - 0 1516623793867 2 connected 10924-16383</span><br><span class="line">4e9c6efe120db6463f42512130ed3fc0d1e5d5b8 127.0.0.1:6393 master - 0 1516623792848 1 connected 0-5461</span><br><span class="line">f3fd6e3bb7c4ae9a0c8f33472096109fd7344d4b 127.0.0.1:6567 slave 4e9c6efe120db6463f42512130ed3fc0d1e5d5b8 0 1516623793356 1 connected</span><br></pre></td></tr></table></figure><p>这是<strong>Redis-4.0.6</strong>对于<code>CLUSTER NODES</code>命令的回复消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0c32e45ddadca3567ac72f6dd94e034f6daed31e 127.0.0.1:7002@17002 master - 0 1516795121251 2 connected 10923-16383</span><br><span class="line">1ca678b62e6935fc7aa274ac7e91d0e7ea752810 127.0.0.1:7000@17000 myself,master - 0 1516795120000 1 connected 0-5460</span><br><span class="line">adc7904694341b4a6a9e1946d483f92769b99473 127.0.0.1:7001@17001 master - 0 1516795120244 0 connected 5461-10922</span><br></pre></td></tr></table></figure><p>可以看出从Redis新版本的回复消息中，仅通过<strong>“：”</strong>已无法获得端口号，于是就会报异常<strong>“7002@17002”无法解析为端口号</strong>。而这个问题从<strong>Jedis-2.8</strong>就被解决了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jedis源码分析共有四个章节，以下为各章链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062801/&quot;&gt;Jedis源码分析(一) - Jedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062802/&quot;&gt;Jedis源码分析(二) - Jedis类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062803/&quot;&gt;Jedis源码分析(三) - JedisCluster类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062804/&quot;&gt;Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Jedis" scheme="http://techblog.ppdai.com/tags/Jedis/"/>
    
  </entry>
  
  <entry>
    <title>Jedis源码分析(二) - Jedis类结构及实现</title>
    <link href="http://techblog.ppdai.com/2018/06/28/2018062802/"/>
    <id>http://techblog.ppdai.com/2018/06/28/2018062802/</id>
    <published>2018-06-28T12:34:11.000Z</published>
    <updated>2018-07-02T13:40:14.300Z</updated>
    
    <content type="html"><![CDATA[<p>Jedis源码分析共有四个章节，以下为各章链接：</p><ol><li><a href="/2018/06/28/2018062801/">Jedis源码分析(一) - Jedis介绍</a></li><li><a href="/2018/06/28/2018062802/">Jedis源码分析(二) - Jedis类结构及实现</a></li><li><a href="/2018/06/28/2018062803/">Jedis源码分析(三) - JedisCluster类结构及实现</a></li><li><a href="/2018/06/28/2018062804/">Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍</a></li></ol><a id="more"></a><h2 id="Jedis的类结构"><a href="#Jedis的类结构" class="headerlink" title="Jedis的类结构"></a>Jedis的类结构</h2><p>首先看Jedis的内部结构，图2-1中用橘色框标出了主要支架, 为突出主要架构，或有稍许内容没有标出。</p><p><img src="/2018/06/28/2018062802/image003.png" alt="avatar"></p><center style="margin: -20px 0 20px">图1-1 Jedis的类结构</center><p>​          Jedis以输入的命令参数是否为二进制，将处理请求的具体实现部署在两个类中，例如<code>Jedis</code>和<code>BinaryJedis</code>，<code>Client</code>和<code>BinaryClient</code>。与Redis服务器的连接信息（Socket,host,port……）封装在<code>Client</code>的基类<code>Connection</code>中。<code>BinaryJedis</code>类中提供了Client,Pipeline和Transcation变量，对应3种请求模式。</p><h2 id="Jedis的初始化流程"><a href="#Jedis的初始化流程" class="headerlink" title="Jedis的初始化流程"></a>Jedis的初始化流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>, <span class="number">6379</span>, <span class="number">15000</span>);</span><br><span class="line">Transaction t = jedis.multi();</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br></pre></td></tr></table></figure><p>Jedis通过传入Redis服务器地址（host,port）开始初始化，然后在BinaryJedis里实例化Client。Client通过<strong>Socket</strong>维持客户端与Redis服务器的连接与沟通。</p><p>前文提到Transaction和Pipeline很相似，它们继承同一个基类<code>MultiKeyPipelineBase</code>。区别在于Transaction在实例化的时候，就自动发送<strong>MULTI</strong>命令，开启事务模式，而Pipeline则按情况手动开启，它们均依靠Client发送命令。以下是Transaction和Pipeline初始化的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BinaryJedis类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">multi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">client.multi();</span><br><span class="line">transaction = <span class="keyword">new</span> Transaction(client);</span><br><span class="line"><span class="keyword">return</span> transaction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Pipeline <span class="title">pipelined</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pipeline = <span class="keyword">new</span> Pipeline();</span><br><span class="line">pipeline.setClient(client);</span><br><span class="line"><span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过发送一个<code>get key</code> 的命令，看看，这三种模式是如何运转的。</p><h2 id="Jedis工作模式的调用流程"><a href="#Jedis工作模式的调用流程" class="headerlink" title="Jedis工作模式的调用流程"></a>Jedis工作模式的调用流程</h2><h3 id="client请求模式"><a href="#client请求模式" class="headerlink" title="client请求模式"></a>client请求模式</h3><p>以<code>get key</code> 为例，为突出主要步骤，部分代码略有缩减。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.get(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><p><img src="/2018/06/28/2018062802/image004.png" alt="avatar"></p><center style="margin: -20px 0 20px">图3-1 Clinet模式的时序图</center><p><img src="/2018/06/28/2018062802/image005.png" alt="avatar"></p><center style="margin: -20px 0 20px">图3-2 Client模式的调用流程</center><p>图3-1和3-2是client模式下，发送请求，读取回复的具体实现。可以清楚看到，在每次发送命令前，会先通过<code>connect()</code>方法判断是否已经连接，若未连接则进行如下操作：</p><ol><li>实例化Socket，并配置，</li><li>连接Socket,获取OutputStream和InputStream</li><li>如果是SSL连接，则会通过SSLSocketFactory创建socket连接</li></ol><p><strong>Protocol</strong>是一个通讯工具类，将Redis的各类执行关键字存储为静态变量，可以直观调用命令，例如<code>Protocol.Command.GET</code>。同时，将命令包装成符合<a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="noopener">Redis的统一请求协议</a>，回复消息的处理也是在这个类进行，先通过通讯协提取出当次请求的回复消息，将Object类型的消息，格式化为String,List等具体类型，如果回复消息有Error则以异常的形式抛出。</p><h3 id="Pipeline和Transaction模式"><a href="#Pipeline和Transaction模式" class="headerlink" title="Pipeline和Transaction模式"></a>Pipeline和Transaction模式</h3><p><img src="/2018/06/28/2018062802/image006.png" alt="avatar"></p><center style="margin: -20px 0 20px">图3-3 Transaction和Pipeline的类结构</center><p>图3-3是Transaction和Pipeline两个类的的类结构。可以看到Pipeline和Transaction都继承自<code>MultiKeyPipelineBase</code>，其中，<code>MultiKeyPipelineBase</code>和<code>PipelineBase</code>的区别在于处理的命令不同，内部均调用Client发送命令。从以下用例也可以看出两者的操作也十分类似。Pipeline有一个内部类对象<code>MultiResponseBuilder</code>，前文提到，当Redis事务结束时，会以List的形式，一次性返回所有命令的执行结果。<code>MultiResponseBuilder</code>对象就是用于，当Pipeline开始其实模式后，在事务结束时，存储所有返回结果。</p><p>Queable用一个LinkedList装入每个命令的返回结果，<code>Response&lt;T&gt;</code>是一个泛型，<code>set(Object data)</code>方法传入格式化之前的结果，<code>get()</code>方法返回格式化之后的结果。<br>Pipeline的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Pipeline p = jedis.pipelined();</span><br><span class="line"><span class="comment">//只发送命令，不读取结果，此时的Response&lt;T&gt;没有数据</span></span><br><span class="line">Response&lt;String&gt; string = p.get(<span class="string">"string"</span>);</span><br><span class="line">Response&lt;String&gt; list = p.lpop(<span class="string">"list"</span>);</span><br><span class="line">Response&lt;String&gt; hash = p.hget(<span class="string">"hash"</span>, <span class="string">"foo"</span>);</span><br><span class="line">Response&lt;Set&lt;String&gt;&gt; zset = p.zrange(<span class="string">"zset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">Response&lt;String&gt; set = p.spop(<span class="string">"set"</span>);</span><br><span class="line"><span class="comment">//一次读取所有response.此时的Response&lt;T&gt;有数据</span></span><br><span class="line">p.sync();</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">"foo"</span>, string.get());</span><br><span class="line">assertEquals(<span class="string">"foo"</span>, list.get());</span><br><span class="line">assertEquals(<span class="string">"bar"</span>, hash.get());</span><br><span class="line">assertEquals(<span class="string">"foo"</span>, zset.get().iterator().next());</span><br><span class="line">assertEquals(<span class="string">"foo"</span>, set.get());</span><br><span class="line"></span><br><span class="line">Transactions使用方法：</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction t = jedis.multi();</span><br><span class="line"><span class="comment">//命令进入服务端的待执行队列</span></span><br><span class="line">Response&lt;String&gt; string = t.get(<span class="string">"string"</span>);</span><br><span class="line">Response&lt;String&gt; list = t.lpop(<span class="string">"list"</span>);</span><br><span class="line">Response&lt;String&gt; hash = t.hget(<span class="string">"hash"</span>, <span class="string">"foo"</span>);</span><br><span class="line">Response&lt;Set&lt;String&gt;&gt; zset = t.zrange(<span class="string">"zset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">Response&lt;String&gt; set = t.spop(<span class="string">"set"</span>);</span><br><span class="line"><span class="comment">//发送EXEC指令，执行所有命令，并返回结果</span></span><br><span class="line">t.exec();</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">"foo"</span>, string.get());</span><br><span class="line">assertEquals(<span class="string">"foo"</span>, list.get());</span><br><span class="line">assertEquals(<span class="string">"bar"</span>, hash.get());</span><br><span class="line">assertEquals(<span class="string">"foo"</span>, zset.get().iterator().next());</span><br><span class="line">assertEquals(<span class="string">"foo"</span>, set.get());</span><br></pre></td></tr></table></figure><p><img src="/2018/06/28/2018062802/image007.png" alt="avatar"></p><center style="margin: -20px 0 20px">图3-4 Pipeline的调用时序图</center><p><img src="/2018/06/28/2018062802/image008.png" alt="avatar"></p><center style="margin: -20px 0 20px">图3-5 Pipeline的调用流程</center><p>图3-4，3-5显示了Pipeline从发送请求到读取回复的具体实现，Transaction的实现与其类似，因而没有另外做图说明。由上图可见，Pipeline通过Client发送命令，Client在<code>sendCommand</code>时，会同时执行<code>pipelinedCommands++</code>，记录发送命令的条数（参见图3-5）。之后，返回一个<code>Response&lt;T&gt;</code>实例，并将这个实例塞入了<code>pipelinedResponses</code>队列中。<code>Response&lt;T&gt;</code>主要有3个属性：</p><ol><li>格式化前的回复消息data,</li><li>格式化后的回复消息response,</li><li>格式化方式builder。</li></ol><p>​        刚发送消息后，<code>Response&lt;T&gt;</code>里面的<code>data</code>和<code>response</code>是空值，只有格式化的方式<code>builder</code>。<code>Sync()</code>用于一次性读取所有回复，首先调用client的<code>getAll()</code>方法，<code>getAll()</code>方法根据之前记录的<code>pipelinedCommands</code>和Redis通讯协议，读取相同条数的回复消息到一个List，并返回给Pipeline。随后遍历这个List,逐个将回复消息赋给<code>pipelinedResponses</code>中每个<code>Response&lt;T&gt;</code>的<code>data</code>。</p><p>在执行<code>Response&lt;T&gt;.get()</code>命令时，<code>Response&lt;T&gt;</code>里面<code>data</code>已经有值了，但是是Object类型的，因而还要调用<code>build()</code>方法，做一次数据转换，返回格式化之后的数据。</p><p>以上就是Pipeline的主要工作流程。Transaction的<code>exec()</code>方法和<code>sync()</code>很相似，下文为<code>exec()</code>的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清空inputstream里面的所有数据，忽略QUEUED or ERROR回复</span></span><br><span class="line">  client.getMany(getPipelinedResponseLength());</span><br><span class="line">  <span class="comment">//发送EXEC指令，让服务端执行所有命令</span></span><br><span class="line">  client.exec();</span><br><span class="line">  <span class="comment">//事务结束</span></span><br><span class="line">  inTransaction = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//从inputStream中读取所有回复</span></span><br><span class="line">  List&lt;Object&gt; unformatted = client.getObjectMultiBulkReply();</span><br><span class="line">  <span class="keyword">if</span> (unformatted == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//和sync（）一样</span></span><br><span class="line">  List&lt;Object&gt; formatted = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Object o : unformatted) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     formatted.add(generateResponse(o).get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisDataException e) &#123;</span><br><span class="line">    formatted.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> formatted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节虽未将Pipeline和Transaction的方法实现尽述，但也大同小异。关键点在于理解第一章介绍的3类请求逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jedis源码分析共有四个章节，以下为各章链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062801/&quot;&gt;Jedis源码分析(一) - Jedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062802/&quot;&gt;Jedis源码分析(二) - Jedis类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062803/&quot;&gt;Jedis源码分析(三) - JedisCluster类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062804/&quot;&gt;Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Jedis" scheme="http://techblog.ppdai.com/tags/Jedis/"/>
    
  </entry>
  
  <entry>
    <title>Jedis源码分析(一) - Jedis介绍</title>
    <link href="http://techblog.ppdai.com/2018/06/28/2018062801/"/>
    <id>http://techblog.ppdai.com/2018/06/28/2018062801/</id>
    <published>2018-06-28T09:15:26.000Z</published>
    <updated>2018-07-02T13:40:19.829Z</updated>
    
    <content type="html"><![CDATA[<p>Jedis源码分析共有四个章节，以下为各章链接：</p><ol><li><a href="/2018/06/28/2018062801/">Jedis源码分析(一) - Jedis介绍</a></li><li><a href="/2018/06/28/2018062802/">Jedis源码分析(二) - Jedis类结构及实现</a></li><li><a href="/2018/06/28/2018062803/">Jedis源码分析(三) - JedisCluster类结构及实现</a></li><li><a href="/2018/06/28/2018062804/">Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍</a></li></ol><a id="more"></a><h2 id="Jedis对应Redis的四种工作模式"><a href="#Jedis对应Redis的四种工作模式" class="headerlink" title="Jedis对应Redis的四种工作模式"></a>Jedis对应Redis的四种工作模式</h2><p><img src="/2018/06/28/2018062801/image001.png" alt="avatar"></p><center style="margin: -20px 0 20px">图1-1 Jedis的主要模块</center><p>图1-1是Jedis的主要模块，Jedis,JedisCluster,JedisSentinel和ShardedJedis对应了Redis的四种工作模式：Redis Standalone（单节点模式）,Redis Cluster（集群模式）,Redis Sentinel（哨兵模式）和Redis Sharding（分片模式）。</p><h2 id="Jedis的三种请求模式"><a href="#Jedis的三种请求模式" class="headerlink" title="Jedis的三种请求模式"></a>Jedis的三种请求模式</h2><p>​       每个Jedis实例对应一个Redis节点，我们对Jedis实例的每个操作，都相当于使用<code>redis-cli</code>启动客户端的直接操作。无论是集群模式，哨兵模式，还是分片模式，内部均为对Jedis实例的操作。所以了解Jedis类的内部结构及Jedis实例的请求模式是掌握Jedis框架的基础。</p><p>Jedis实例有3种请求模式，Pipeline，Transaction和Client。</p><p><img src="/2018/06/28/2018062801/image002.png" alt="avatar"></p><center style="margin: -20px 0 20px">图2-1 Jedis的三种请求模式</center><p>Jedis实例通过<strong>Socket</strong>建立客户端与服务端的长连接，往<strong>outputStream</strong>发送命令，从<strong>inputStream</strong>读取回复，图2-1显示Redis常用的3种请求模式，下文是详细说明：</p><h3 id="Client模式"><a href="#Client模式" class="headerlink" title="Client模式"></a>Client模式</h3><p>Client模式就是常用的“所见即所得”，客户端发一个命令，阻塞等待服务端执行，然后读取返回结果。优点是确保每次处理都有结果，一旦发现返回结果中有Error,就可以立即处理。</p><h3 id="Pipeline模式"><a href="#Pipeline模式" class="headerlink" title="Pipeline模式"></a>Pipeline模式</h3><p>Pipeline模式则是一次性发送多个命令，最后一次取回所有的返回结果，这种模式通过减少网络的往返时间和IO的读写次数，大幅度提高通信性能，但Pipeline不支持原子性，如果想保证原子性，可同时开启事务模式。</p><h3 id="Transaction模式"><a href="#Transaction模式" class="headerlink" title="Transaction模式"></a>Transaction模式</h3><p>Transaction模式即开启Redis的事务管理，Pipeline可以在事务中，也可以不在事务中。事务模式开启后，所有的命令（除了 <strong>EXEC</strong> 、 <strong>DISCARD</strong> 、 <strong>MULTI</strong> 和 <strong>WATCH</strong> ）到达服务端以后，不会立即执行，会进入一个等待队列，等到收到下述四个命令时执行不同操作：</p><ol><li><strong>EXEC</strong>命令执行时， 服务器以先进先出（FIFO）的方式执行事务队列中的命令,当事务队列里的所有命令被执行完之后， 将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。    </li><li><strong>DISCARD</strong>命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</li><li><strong>Redis</strong> 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送MULTI时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</li><li><strong>WATCH</strong>只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI的情况一样）。</li></ol><p>Jedis主要有两条业务逻辑：1）初始化的过程，2）发送命令的过程。下面将摸索着2条主线来学习。本文源码解析基于Jedis-2.10，为突出主要架构，部分内容稍有删减。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jedis源码分析共有四个章节，以下为各章链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062801/&quot;&gt;Jedis源码分析(一) - Jedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062802/&quot;&gt;Jedis源码分析(二) - Jedis类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062803/&quot;&gt;Jedis源码分析(三) - JedisCluster类结构及实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2018/06/28/2018062804/&quot;&gt;Jedis源码分析(四) - JedisSentinel与ShardedJedis介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Jedis" scheme="http://techblog.ppdai.com/tags/Jedis/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud-openfeign原理分析</title>
    <link href="http://techblog.ppdai.com/2018/05/28/20180528/"/>
    <id>http://techblog.ppdai.com/2018/05/28/20180528/</id>
    <published>2018-05-28T08:56:03.000Z</published>
    <updated>2018-06-28T09:20:44.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">feign</a>是一个声明试的HTTP客户端，spring-cloud-openfeign将feign集成到spring boot中，在接口上通过注解声明Rest协议，将http调用转换为接口方法的调用，使得客户端调用http服务更加简单。</p><p>当前spring cloud最新稳定版本是Edgware，feign在其集成的<a href="https://github.com/spring-cloud/spring-cloud-netflix" target="_blank" rel="noopener">spring-cloud-netflix</a> 1.4.0.RELEASE版本中。</p><blockquote><p>spring cloud下一个版本是Finchley，将会单独集成<a href="https://github.com/spring-cloud/spring-cloud-openfeign" target="_blank" rel="noopener">spring-cloud-openfeign</a></p></blockquote><a id="more"></a><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>我们来看个简单的例子。源代码链接：<a href="https://github.com/along101/spring-boot-test/tree/master/feign-test" target="_blank" rel="noopener">https://github.com/along101/spring-boot-test/tree/master/feign-test</a></p><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><p>使用spring boot编写一个简单的Rest服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello1"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码很简单，通过springMVC注解在接口HelloService上声明Rest服务，HelloController被@RestController注解声明为一个Rest服务。</p><p>启动spring boot 就可通过浏览器访问<a href="http://localhost:8080/test/hello1?name=ppdai得到返回Hello" target="_blank" rel="noopener">http://localhost:8080/test/hello1?name=ppdai得到返回Hello</a> ppdai。</p><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><p>客户端pom中需要加入spring-cloud-starter-feign的依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>Camden.SR7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在客户端中新建一个HelloClient接口继承服务端HelloService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在spring boot配置文件中配置remote.hello.service.host=http://localhost:8080</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"HELLO-SERVICE"</span>, url = <span class="string">"$&#123;remote.hello.service.host&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> <span class="keyword">extends</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloClient接口上注解@FeignClient，声明为Feign的客户端，参数url指定服务端地址。<br>在spring boot启动类上增加注解@EnableFeignClients</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，HelloClient接口需要在启动类package或者子package之下。<br>编写测试类测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = FeignClientApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClientTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result = helloClient.hello(<span class="string">"ppdai"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动服务端后，运行该测试类，在控制台会打印出<code>Hello ppdai</code></p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>看到客户端测试类中，我们只用了一行代码，就能完成对远程Rest服务的调用，相当的简单。为什么这么神奇，这几段代码是如何做到的呢？</p><h2 id="EnableFeignClients-注解声明客户端接口"><a href="#EnableFeignClients-注解声明客户端接口" class="headerlink" title="@EnableFeignClients 注解声明客户端接口"></a>@EnableFeignClients 注解声明客户端接口</h2><p>入口是启动类上的注解@EnableFeignClients，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line"><span class="comment">//basePackages的别名</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//声明基础包，spring boot启动后，会扫描该包下被@FeignClient注解的接口</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//声明基础包的类，通过该类声明基础包</span></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//默认配置类</span></span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//直接声明的客户端接口类</span></span><br><span class="line">Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableFeignClients的参数声明客户端接口的位置和默认的配置类。</p><h3 id="FeignClient注解，将接口声明为Feign客户端"><a href="#FeignClient注解，将接口声明为Feign客户端" class="headerlink" title="@FeignClient注解，将接口声明为Feign客户端"></a>@FeignClient注解，将接口声明为Feign客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FeignClient &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//名称，对应与eureka上注册的应用名</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//生成spring bean的qualifier</span></span><br><span class="line"><span class="function">String <span class="title">qualifier</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//http服务的url</span></span><br><span class="line"><span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">decode404</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="comment">//配置类，这里设置的配置类是Spring Configuration，将会在FeignContext中创建内部声明的Bean，用于不同的客户端进行隔离</span></span><br><span class="line">Class&lt;?&gt;[] configuration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//声明hystrix调用失败后的方法</span></span><br><span class="line">Class&lt;?&gt; fallback() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line">Class&lt;?&gt; fallbackFactory() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"><span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FeignClientsRegistrar-注册客户端"><a href="#FeignClientsRegistrar-注册客户端" class="headerlink" title="FeignClientsRegistrar 注册客户端"></a>FeignClientsRegistrar 注册客户端</h2><p>@EnableFeignClients注解上被注解了@Import(FeignClientsRegistrar.class)，@Import注解的作用是将指定的类作为Bean注入到Spring Context中，我们再来看被引入的FeignClientsRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">registerDefaultConfiguration(metadata, registry);</span><br><span class="line">registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientsRegistrar类实现了3个接口:</p><ul><li>接口ResourceLoaderAware用于注入ResourceLoader</li><li>接口BeanClassLoaderAware用于注入ClassLoader</li><li>接口ImportBeanDefinitionRegistrar用于动态向Spring Context中注册bean</li></ul><p>ImportBeanDefinitionRegistrar接口方法registerBeanDefinitions有两个参数</p><ul><li>AnnotationMetadata 包含被@Import注解类的信息</li></ul><blockquote><p>这里 @Import注解在@EnableFeignClients上，@EnableFeignClients注解在spring boot启动类上，AnnotationMetadata拿到的是spring boot启动类的相关信息</p></blockquote><ul><li>BeanDefinitionRegistry bean定义注册中心</li></ul><h2 id="registerDefaultConfiguration方法，注册默认配置"><a href="#registerDefaultConfiguration方法，注册默认配置" class="headerlink" title="registerDefaultConfiguration方法，注册默认配置"></a>registerDefaultConfiguration方法，注册默认配置</h2><p>registerDefaultConfiguration方法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取@EnableFeignClients注解参数</span></span><br><span class="line">Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//如果参数中包含defaultConfiguration</span></span><br><span class="line"><span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册客户端的配置Bean</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出@EnableFeignClients注解参数defaultConfiguration，注册到spring Context中。registerClientConfiguration方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">Object configuration)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个BeanDefinitionBuilder，注册bean的类为FeignClientSpecification</span></span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line"><span class="comment">//增加构造函数参数</span></span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line"><span class="comment">//调用BeanDefinitionRegistry.registerBeanDefinition方法动态注册Bean</span></span><br><span class="line">registry.registerBeanDefinition(</span><br><span class="line">name + <span class="string">"."</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用spring 动态注册bean的方式，注册了一个FeignClientSpecification的bean。</p><h2 id="FeignClientSpecification-客户端定义"><a href="#FeignClientSpecification-客户端定义" class="headerlink" title="FeignClientSpecification 客户端定义"></a>FeignClientSpecification 客户端定义</h2><p>一个简单的pojo，继承了NamedContextFactory.Specification，两个属性String name 和 Class&lt;?&gt;[] configuration，用于FeignContext命名空间独立配置，后面会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientSpecification</span> <span class="keyword">implements</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] configuration;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="registerFeignClients方法，注册feign客户端"><a href="#registerFeignClients方法，注册feign客户端" class="headerlink" title="registerFeignClients方法，注册feign客户端"></a>registerFeignClients方法，注册feign客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成一个scanner，扫描注定包下的类</span></span><br><span class="line">ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line"><span class="comment">//包含@FeignClient注解的过滤器</span></span><br><span class="line">AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">FeignClient.class);</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">: (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line"><span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//@EnableFeignClients没有声明clients，获取basePackages，设置过滤器</span></span><br><span class="line">scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">basePackages = getBasePackages(metadata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//@EnableFeignClients声明了clients</span></span><br><span class="line"><span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//basePackages为声明的clients所在的包</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加过滤器，只包含声明的clients</span></span><br><span class="line">AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line"><span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">scanner.addIncludeFilter(</span><br><span class="line"><span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历basePackages</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//扫描包，根据过滤器找到候选的Bean</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">.findCandidateComponents(basePackage);</span><br><span class="line"><span class="comment">// 遍历候选的bean</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 校验注解是否是注解在接口上</span></span><br><span class="line">AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line"><span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"><span class="comment">// 获取注解属性</span></span><br><span class="line">Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">.getAnnotationAttributes(</span><br><span class="line">FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">String name = getClientName(attributes);</span><br><span class="line"><span class="comment">//注册客户端配置</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line"><span class="comment">//注册客户端</span></span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要逻辑是扫描注解声明的客户端，调用registerFeignClient方法注册到registry中。这里是一个典型的spring动态注册bean的例子，可以参考这段代码在spring中轻松的实现类路径下class扫描，动态注册bean到spring中。想了解spring类的扫描机制，可以断点到ClassPathScanningCandidateComponentProvider.findCandidateComponents方法中，一步步调试。</p><h2 id="registerFeignClient方法，注册单个客户feign端"><a href="#registerFeignClient方法，注册单个客户feign端" class="headerlink" title="registerFeignClient方法，注册单个客户feign端"></a>registerFeignClient方法，注册单个客户feign端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">String className = annotationMetadata.getClassName();</span><br><span class="line"><span class="comment">//构建一个FeignClientFactoryBean的bean工厂定义</span></span><br><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">validate(attributes);</span><br><span class="line"><span class="comment">//根据@FeignClient注解的参数，设置属性</span></span><br><span class="line">definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">String name = getName(attributes);</span><br><span class="line">definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line">beanDefinition.setPrimary(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置qualifier</span></span><br><span class="line">String qualifier = getQualifier(attributes);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">alias = qualifier;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册，这里为了简写，新建一个BeanDefinitionHolder，调用BeanDefinitionReaderUtils静态方法注册</span></span><br><span class="line">BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line"><span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerFeignClient方法主要是将FeignClientFactoryBean工厂Bean注册到registry中，spring初始化后，会调用FeignClientFactoryBean的getObject方法创建bean注册到spring context中。</p><h2 id="FeignClientFactoryBean-创建feign客户端的工厂"><a href="#FeignClientFactoryBean-创建feign客户端的工厂" class="headerlink" title="FeignClientFactoryBean 创建feign客户端的工厂"></a>FeignClientFactoryBean 创建feign客户端的工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">InitializingBean</span>,</span></span><br><span class="line"><span class="class"><span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">//feign客户端接口类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> decode404;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"><span class="comment">//hystrix集成，调用失败的执行方法</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; fallback = <span class="keyword">void</span>.class;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; fallbackFactory = <span class="keyword">void</span>.class;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientFactoryBean实现了FactoryBean接口，是一个工厂bean</p><h3 id="FeignClientFactoryBean-getObject方法"><a href="#FeignClientFactoryBean-getObject方法" class="headerlink" title="FeignClientFactoryBean.getObject方法"></a>FeignClientFactoryBean.getObject方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//FeignContext在FeignAutoConfiguration中自动注册，FeignContext用于客户端配置类独立注册，后面具体分析</span></span><br><span class="line">FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line"><span class="comment">//创建Feign.Builder</span></span><br><span class="line">Feign.Builder builder = feign(context);</span><br><span class="line"><span class="comment">//如果@FeignClient注解没有设置url参数</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">String url;</span><br><span class="line"><span class="comment">//url为@FeignClient注解的name参数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">url = <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加上path</span></span><br><span class="line">url += cleanPath();</span><br><span class="line"><span class="comment">//返回loadBlance客户端，也就是ribbon+eureka的客户端</span></span><br><span class="line"><span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line"><span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@FeignClient设置了url参数，不做负载均衡</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加上path</span></span><br><span class="line">String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line"><span class="comment">//从FeignContext中获取client</span></span><br><span class="line">Client client = getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line"><span class="comment">// 有url参数，不做负载均衡，但是客户端是ribbon，或者实际的客户端</span></span><br><span class="line">client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">&#125;</span><br><span class="line">builder.client(client);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从FeignContext中获取Targeter</span></span><br><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="comment">//生成客户端代理</span></span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line"><span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有个比较重要的逻辑，如果在@FeignClient注解中设置了url参数，就不走Ribbon，直接url调用，否则通过Ribbon调用，实现客户端负载均衡。</p><p>可以看到，生成Feign客户端所需要的各种配置对象，都是通过FeignContex中获取的。</p><h3 id="FeignContext-隔离配置"><a href="#FeignContext-隔离配置" class="headerlink" title="FeignContext 隔离配置"></a>FeignContext 隔离配置</h3><p>在@FeignClient注解参数configuration，指定的类是Spring的Configuration Bean，里面方法上加@Bean注解实现Bean的注入，可以指定feign客户端的各种配置，包括Encoder/Decoder/Contract/Feign.Builder等。不同的客户端指定不同配置类，就需要对配置类进行隔离，FeignContext就是用于隔离配置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignContext</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">FeignClientSpecification</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FeignContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(FeignClientsConfiguration.class, <span class="string">"feign"</span>, <span class="string">"feign.client.name"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignContext继承NamedContextFactory，空参数构造函数指定FeignClientsConfiguration类为默认配置。<br>NamedContextFactory实现接口ApplicationContextAware，注入ApplicationContextAware作为parent：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">//命名空间对应的Spring Context</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//不同命名空间的定义</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//父ApplicationContext，通过ApplicationContextAware接口注入</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"><span class="comment">//默认配置类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//设置配置，在FeignAutoConfiguration中将Spring Context中的所有FeignClientSpecification设置进来，如果@EnableFeignClients有设置参数defaultConfiguration也会加进来，前面已经分析在registerDefaultConfiguration方法中注册的FeignClientSpecification Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurations</span><span class="params">(List&lt;C&gt; configurations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (C client : configurations) &#123;</span><br><span class="line"><span class="keyword">this</span>.configurations.put(client.getName(), client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定命名空间的ApplicationContext，先从缓存中获取，没有就创建</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建AnnotationConfigApplicationContext</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"><span class="comment">//根据name在configurations找到所有的配置类，注册到context总</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将default.开头的默认默认也注册到Context中</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册一些需要的bean</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 设置parent</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//刷新，完成bean生成</span></span><br><span class="line">context.refresh();</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从命名空间中获取指定类型的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从命名空间中获取指定类型的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getInstances</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> BeanFactoryUtils.beansOfTypeIncludingAncestors(context, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的方法是createContext，为每个命名空间独立创建ApplicationContext，设置parent为外部传入的Context，这样就可以共用外部的Context中的Bean，又有各种独立的配置Bean，熟悉springMVC的同学应该知道，springMVC中创建的WebApplicatonContext里面也有个parent，原理跟这个类似。</p><p>从FeignContext中获取Bean，需要传入命名空间，根据命名空间找到缓存中的ApplicationContext，先从自己注册的Bean中获取bean，没有获取到再从到parent中获取。</p><h3 id="创建Feign-Builder"><a href="#创建Feign-Builder" class="headerlink" title="创建Feign.Builder"></a>创建Feign.Builder</h3><p>了解了FeignContext的原理，我们再来看feign最重要的构建类创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//从FeignContext中获取注册的Feign.Builder bean，设置Encoder/Decoder/Contract</span></span><br><span class="line">Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">.logger(logger)</span><br><span class="line">.encoder(get(context, Encoder.class))</span><br><span class="line">.decoder(get(context, Decoder.class))</span><br><span class="line">.contract(get(context, Contract.class));</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//设置feign其他参数，都从FeignContext中获取</span></span><br><span class="line">Retryer retryer = getOptional(context, Retryer.class);</span><br><span class="line"><span class="keyword">if</span> (retryer != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.retryer(retryer);</span><br><span class="line">&#125;</span><br><span class="line">ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class);</span><br><span class="line"><span class="keyword">if</span> (errorDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.errorDecoder(errorDecoder);</span><br><span class="line">&#125;</span><br><span class="line">Request.Options options = getOptional(context, Request.Options.class);</span><br><span class="line"><span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.options(options);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, RequestInterceptor&gt; requestInterceptors = context.getInstances(</span><br><span class="line"><span class="keyword">this</span>.name, RequestInterceptor.class);</span><br><span class="line"><span class="keyword">if</span> (requestInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.requestInterceptors(requestInterceptors.values());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (decode404) &#123;</span><br><span class="line">builder.decode404();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里设置了Feign.Builder所必须的参数Encoder/Decoder/Contract，其他参数都是可选的。这三个必须的参数从哪里来的呢？答案是在FeignContext的构造器中，传入了默认的配置FeignClientsConfiguration，这个配置类里面初始化了这三个参数。</p><h3 id="FeignClientsConfiguration-客户端默认配置"><a href="#FeignClientsConfiguration-客户端默认配置" class="headerlink" title="FeignClientsConfiguration 客户端默认配置"></a>FeignClientsConfiguration 客户端默认配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientsConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//注入springMVC的HttpMessageConverters</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"><span class="comment">//注解参数处理器，处理SpringMVC注解，生成http元数据</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;AnnotatedParameterProcessor&gt; parameterProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//Decoder bean，默认通过HttpMessageConverters进行处理</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Decoder <span class="title">feignDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDecoder(<span class="keyword">new</span> SpringDecoder(<span class="keyword">this</span>.messageConverters));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Encoder bean，默认通过HttpMessageConverters进行处理</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Encoder <span class="title">feignEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringEncoder(<span class="keyword">this</span>.messageConverters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Contract bean，通过SpringMvcContract进行处理接口</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">(ConversionService feignConversionService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringMvcContract(<span class="keyword">this</span>.parameterProcessors, feignConversionService);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hystrix自动注入</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//HystrixFeign的builder，全局关掉Hystrix配置feign.hystrix.enabled=false</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"feign.hystrix.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认不重试</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retryer <span class="title">feignRetryer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Retryer.NEVER_RETRY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的builder</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Feign.builder().retryer(retryer);</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，feign需要的decoder/enoder通过适配器共用springMVC中的HttpMessageConverters引入。</p><p>feign有自己的注解体系，这里通过SpringMvcContract适配了springMVC的注解体系。</p><h3 id="SpringMvcContract-适配feign注解体系"><a href="#SpringMvcContract-适配feign注解体系" class="headerlink" title="SpringMvcContract 适配feign注解体系"></a>SpringMvcContract 适配feign注解体系</h3><p>SpringMvcContract继承了feign的类Contract.BaseContract，作用是解析接口方法上的注解和方法参数，生成MethodMetadata用于接口方法调用过程中组装http请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcContract</span> <span class="keyword">extends</span> <span class="title">Contract</span>.<span class="title">BaseContract</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理Class上的注解</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata data, Class&lt;?&gt; clz)</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodMetadata <span class="title">parseAndValidateMetadata</span><span class="params">(Class&lt;?&gt; targetType, Method method)</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理方法上的注解</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">Annotation methodAnnotation, Method method)</span> </span>&#123;</span><br><span class="line">        。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理参数上的注解</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">  Annotation[] annotations, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个覆盖方法分别是处理类上的注解，处理方法，处理方法上的注解，处理方法参数注解，最终生成完整的MethodMetadata。feign自己提供的Contract和扩展javax.ws.rx的Contract原理都是类似的。</p><h3 id="Targeter-生成接口动态代理"><a href="#Targeter-生成接口动态代理" class="headerlink" title="Targeter 生成接口动态代理"></a>Targeter 生成接口动态代理</h3><p>Feign.Builder生成后，就要用Target生成feign客户端的动态代理，这里FeignClientFactoryBean中使用Targeter，Targeter有两个实现类，分别是HystrixTargeter和DefaultTargeter，DefaultTargeter很简单，直接调用HardCodedTarget生成动态代理，HystrixTargeter源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HystrixTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果不是HystrixFeign.Builder，直接调用target生成代理</span></span><br><span class="line"><span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line"><span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到fallback或者fallbackFactory，设置到hystrix中</span></span><br><span class="line">feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line"><span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line"><span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line"><span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line"><span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，接口的动态代理就生成了，然后回到FeignClientFactoryBean工厂bean中，会将动态代理注入到SpringContext，在使用的地方，就可以通过@Autowire方式注入了。</p><h2 id="loadBalance方法，客户端负载均衡"><a href="#loadBalance方法，客户端负载均衡" class="headerlink" title="loadBalance方法，客户端负载均衡"></a>loadBalance方法，客户端负载均衡</h2><p>如果@FeignClient注解中没有配置url参数，将会通过loadBalance方法生成Ribbon的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里获取到的Client是LoadBalancerFeignClient</span></span><br><span class="line">Client client = getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.client(client);</span><br><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadBalancerFeignClient在FeignRibbonClientAutoConfiguration中自动配置的Bean</p><h3 id="LoadBalancerFeignClient-负载均衡客户端"><a href="#LoadBalancerFeignClient-负载均衡客户端" class="headerlink" title="LoadBalancerFeignClient 负载均衡客户端"></a>LoadBalancerFeignClient 负载均衡客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerFeignClient</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取URI</span></span><br><span class="line">URI asUri = URI.create(request.url());</span><br><span class="line"><span class="comment">//获取客户端的名称</span></span><br><span class="line">String clientName = asUri.getHost();</span><br><span class="line">URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line"><span class="comment">//创建RibbonRequest</span></span><br><span class="line">FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line"><span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line">IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line"><span class="comment">//获取FeignLoadBalancer，发请求，转换Response</span></span><br><span class="line"><span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">requestConfig).toResponse();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑也比较简单，就是是配到Ribbon客户端上调用。Ribbon的相关使用和原理就不在本文中描述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>feign本身是一款优秀的开源组件，spring cloud feign又非常巧妙的将feign集成到spring boot中。<br>本文通过对spring cloud feign源代码的解读，详细的分析了feign集成到spring boot中的原理，使我们更加全面的了解到feign的使用。</p><p>spring cloud feign也是一个很好的学习spring boot的例子，从中我们可以学习到：</p><ul><li>spring boot注解声明注入bean</li><li>spring类扫描机制</li><li>spring接口动态注册bean</li><li>spring命名空间隔离ApplicationContext</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OpenFeign/feign&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;feign&lt;/a&gt;是一个声明试的HTTP客户端，spring-cloud-openfeign将feign集成到spring boot中，在接口上通过注解声明Rest协议，将http调用转换为接口方法的调用，使得客户端调用http服务更加简单。&lt;/p&gt;
&lt;p&gt;当前spring cloud最新稳定版本是Edgware，feign在其集成的&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-netflix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring-cloud-netflix&lt;/a&gt; 1.4.0.RELEASE版本中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spring cloud下一个版本是Finchley，将会单独集成&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-openfeign&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring-cloud-openfeign&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="feign" scheme="http://techblog.ppdai.com/tags/feign/"/>
    
      <category term="spring-cloud-openfeign" scheme="http://techblog.ppdai.com/tags/spring-cloud-openfeign/"/>
    
  </entry>
  
  <entry>
    <title>Feign使用教程</title>
    <link href="http://techblog.ppdai.com/2018/05/15/20180515/"/>
    <id>http://techblog.ppdai.com/2018/05/15/20180515/</id>
    <published>2018-05-15T06:33:03.000Z</published>
    <updated>2018-05-15T06:43:26.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Feign是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>, <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html" target="_blank" rel="noopener">JAXRS-2.0</a>和<a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="noopener">WebSocket</a>。Feign 最初是为了降低统一绑定<a href="https://github.com/Netflix/Denominator" target="_blank" rel="noopener">Denominator</a> 到 HTTP API 的复杂度，不区分是否支持 <a href="http://www.slideshare.net/adrianfcole/99problems" target="_blank" rel="noopener">ReSTfulness</a>。</p><h2 id="为什么选择Feign而不是其他"><a href="#为什么选择Feign而不是其他" class="headerlink" title="为什么选择Feign而不是其他"></a>为什么选择Feign而不是其他</h2><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。你也可以直接使用 Apache HttpClient 来实现。但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p><a id="more"></a><h2 id="Feign工作机制"><a href="#Feign工作机制" class="headerlink" title="Feign工作机制"></a>Feign工作机制</h2><p>Feign 通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。然而这也限制了 Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>基本的使用如下所示，一个对于<a href="https://github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/SimpleService.java" target="_blank" rel="noopener">canonical Retrofit sample</a>的适配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">  String login;</span><br><span class="line">  <span class="keyword">int</span> contributions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  GitHub github = Feign.builder()</span><br><span class="line">                       .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                       .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">  List&lt;Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">  <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">    System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>Feign 有许多可以自定义的方面。举个简单的例子，你可以使用 <code>Feign.builder()</code> 来构造一个拥有你自己组件的API接口。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /account/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Account <span class="title">getAccountInfo</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// AccountDecoder 是自己实现的一个Decoder</span></span><br><span class="line">Bank bank = Feign.builder().decoder(<span class="keyword">new</span> AccountDecoder()).target(Bank.class, <span class="string">"https://api.examplebank.com"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="多种接口"><a href="#多种接口" class="headerlink" title="多种接口"></a>多种接口</h2><p>Feign可以提供多种API接口，这些接口都被定义为 <code>Target&lt;T&gt;</code> (默认的实现是 <code>HardCodedTarget&lt;T&gt;</code>), 它允许在执行请求前动态发现和装饰该请求。</p><p>举个例子，下面的这个模式允许使用当前url和身份验证token来装饰每个发往身份验证中心服务的请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloudDNS cloudDNS = Feign.builder().target(<span class="keyword">new</span> CloudIdentityTarget&lt;CloudDNS&gt;(user, apiKey));</span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Feign 包含了 <a href="./example-github">GitHub</a> 和 <a href="./example-wikipedia">Wikipedia</a>  客户端的实现样例.相似的项目也同样在实践中运用了Feign。尤其是它的示例后台程序<a href="https://github.com/Netflix/denominator/tree/master/example-daemon" target="_blank" rel="noopener">example daemon</a>。</p><h2 id="Feign集成模块"><a href="#Feign集成模块" class="headerlink" title="Feign集成模块"></a>Feign集成模块</h2><p>Feign 可以和其他的开源工具集成工作。你可以将这些开源工具集成到 Feign 中来。目前已经有的一些模块如下:</p><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>Gson 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。<br>添加 <code>GsonEncoder</code> 以及 <code>GsonDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GsonCodec codec = <span class="keyword">new</span> GsonCodec();</span><br><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><p>Jackson 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。<br>添加 <code>JacksonEncoder</code> 以及 <code>JacksonDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> JacksonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> JacksonDecoder())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jackson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="Sax"><a href="#Sax" class="headerlink" title="Sax"></a>Sax</h2><p>SaxDecoder 用于解析XML,并兼容普通JVM和Android。下面是一个配置sax来解析响应的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api = Feign.builder()</span><br><span class="line">           .decoder(SAXDecoder.builder()</span><br><span class="line">                              .registerContentHandler(UserIdHandler.class)</span><br><span class="line">                              .build())</span><br><span class="line">           .target(Api.class, <span class="string">"https://apihost"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-sax&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="JAXB"><a href="#JAXB" class="headerlink" title="JAXB"></a>JAXB</h2><p>JAXB 包含了一个编码器和一个解码器，这个可以被用于XML格式的API。<br>添加  <code>JAXBEncoder</code> 以及  <code>JAXBDecoder</code> 到你的  <code>Feign.Builder</code> 中， 如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api = Feign.builder()</span><br><span class="line">           .encoder(<span class="keyword">new</span> JAXBEncoder())</span><br><span class="line">           .decoder(<span class="keyword">new</span> JAXBDecoder())</span><br><span class="line">           .target(Api.class, <span class="string">"https://apihost"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jaxb&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="JAX-RS"><a href="#JAX-RS" class="headerlink" title="JAX-RS"></a>JAX-RS</h2><p>JAXRSContract 使用 JAX-RS 规范重写覆盖了默认的注解处理。下面是一个使用 JAX-RS 的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span> <span class="meta">@Path</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@PathParam(<span class="string">"owner"</span>)</span> String owner, @<span class="title">PathParam</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .contract(<span class="keyword">new</span> JAXRSContract())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><p>Maven依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jaxrs&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>OkHttpClient 使用 OkHttp 来发送 Feign 的请求，OkHttp 支持 SPDY (SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验),并有更好的控制http请求。</p><p>要让 Feign 使用 OkHttp ，你需要将 OkHttp 加入到你的环境变量中区，然后配置 Feign 使用  <code>OkHttpClient</code>，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>RibbonClient 重写了 Feign 客户端的对URL的处理，其添加了 智能路由以及一些其他由Ribbon提供的弹性功能。<br>集成Ribbon需要你将ribbon的客户端名称当做url的host部分来传递，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAppProd是你的ribbon client name</span></span><br><span class="line">MyService api = Feign.builder().client(RibbonClient.create()).target(MyService.class, <span class="string">"https://myAppProd"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-ribbon&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>HystrixFeign 配置了 Hystrix 提供的熔断机制。<br>要在 Feign 中使用 Hystrix ，你需要添加Hystrix模块到你的环境变量，然后使用  <code>HystrixFeign</code> 来构造你的API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyService api = HystrixFeign.builder().target(MyService.class, <span class="string">"https://myAppProd"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h2><p>SLF4JModule 允许你使用 SLF4J 作为 Feign 的日志记录模块，这样你就可以轻松的使用 Logback, Log4J , 等来记录你的日志.</p><p>要在 Feign 中使用 SLF4J ，你需要添加SLF4J模块和对应的日志记录实现模块(比如Log4J)到你的环境变量，然后配置Feign使用Slf4jLogger :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .logger(<span class="keyword">new</span> Slf4jLogger())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-slf4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Decoders"><a href="#Decoders" class="headerlink" title="Decoders"></a>Decoders</h2><p> <code>Feign.builder()</code> 允许你自定义一些额外的配置，比如说如何解码一个响应。假如有接口方法返回的消息不是  <code>Response</code>,  <code>String</code>,  <code>byte[]</code> 或者  <code>void</code> 类型的，那么你需要配置一个非默认的解码器。<br>下面是一个配置使用JSON解码器(使用的是feign-gson扩展)的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(new GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, &quot;https://api.github.com&quot;);</span><br></pre></td></tr></table></figure></p><p>假如你想在将响应传递给解码器处理前做一些额外的处理，那么你可以使用 <code>mapAndDecode</code> 方法。一个用例就是使用jsonp服务的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JsonpApi jsonpApi = Feign.builder()</span><br><span class="line">                         .mapAndDecode((response, type) -&gt; jsopUnwrap(response, type), new GsonDecoder())</span><br><span class="line">                         .target(JsonpApi.class, &quot;https://some-jsonp-api.com&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="Encoders"><a href="#Encoders" class="headerlink" title="Encoders"></a>Encoders</h2><p>发送一个Post请求最简单的方法就是传递一个 <code>String</code> 或者 <code>byte[]</code> 类型的参数了。你也许还需添加一个<code>Content-Type</code>请求头，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">client.login(<span class="string">"&#123;\"user_name\": \"denominator\", \"password\": \"secret\"&#125;"</span>);</span><br></pre></td></tr></table></figure></p><p>通过配置一个解码器，你可以发送一个安全类型的请求体，如下是一个使用 feign-gson 扩展的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String user_name;</span><br><span class="line">  <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">  Credentials(String user_name, String password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.user_name = user_name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(Credentials creds)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">LoginClient client = Feign.builder()</span><br><span class="line">                          .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                          .target(LoginClient.class, <span class="string">"https://foo.com"</span>);</span><br><span class="line"></span><br><span class="line">client.login(<span class="keyword">new</span> Credentials(<span class="string">"denominator"</span>, <span class="string">"secret"</span>));</span><br></pre></td></tr></table></figure></p><h2 id="Body-templates"><a href="#Body-templates" class="headerlink" title="@Body templates"></a>@Body templates</h2><p><code>@Body</code>注解申明一个请求体模板，模板中可以带有参数，与方法中 <code>@Param</code> 注解申明的参数相匹配,使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/xml"</span>)</span><br><span class="line">  <span class="meta">@Body</span>(<span class="string">"&lt;login \"user_name\"=\"&#123;user_name&#125;\" \"password\"=\"&#123;password&#125;\"/&gt;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">xml</span><span class="params">(@Param(<span class="string">"user_name"</span>)</span> String user, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="comment">// json curly braces must be escaped!</span></span><br><span class="line">  <span class="comment">// 这里JSON格式需要的花括号居然需要转码，有点蛋疼了。</span></span><br><span class="line">  <span class="meta">@Body</span>(<span class="string">"%7B\"user_name\": \"&#123;user_name&#125;\", \"password\": \"&#123;password&#125;\"%7D"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">json</span><span class="params">(@Param(<span class="string">"user_name"</span>)</span> String user, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// &lt;login "user_name"="denominator" "password"="secret"/&gt;</span></span><br><span class="line">client.xml(<span class="string">"denominator"</span>, <span class="string">"secret"</span>);</span><br><span class="line"><span class="comment">// &#123;"user_name": "denominator", "password": "secret"&#125;</span></span><br><span class="line">client.json(<span class="string">"denominator"</span>, <span class="string">"secret"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h2><p>Feign 支持给请求的api设置或者请求的客户端设置请求头</p><ul><li><p>使用 <code>@Headers</code> 设置静态请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给BaseApi中的所有方法设置Accept请求头</span></span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"Accept: application/json"</span>)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 单独给put方法设置Content-Type请求头</span></span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"PUT /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置动态值的请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"X-Ping: &#123;token&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(@Param(<span class="string">"token"</span>)</span> String token)</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置key和value都是动态的请求头<br>有些API需要根据调用时动态确定使用不同的请求头(e.g. custom metadata header fields such as “x-amz-meta-” or “x-goog-meta-“),这时候可以使用 <code>@HeaderMap</code> 注解，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @HeaderMap 注解设置的请求头优先于其他方式设置的</span></span><br><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(@HeaderMap Map&lt;String, Object&gt; headerMap)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="给Target设置请求头"><a href="#给Target设置请求头" class="headerlink" title="给Target设置请求头"></a>给Target设置请求头</h2><p>有时我们需要在一个API实现中根据不同的endpoint来传入不同的Header，这个时候我们可以使用自定义的<code>RequestInterceptor</code> 或 <code>Target</code>来实现.<br>通过自定义的 <code>RequestInterceptor</code> 来实现请查看 <code>Request Interceptors</code> 章节.<br>下面是一个通过自定义<code>Targe</code>t来实现给每个<code>Target</code>设置安全校验信息Header的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAuthTokenTarget</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Target</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicAuthTokenTarget</span><span class="params">(Class&lt;T&gt; clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                                UrlAndTokenProvider provider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ThreadLocal&lt;String&gt; requestIdProvider)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Request <span class="title">apply</span><span class="params">(RequestTemplate input)</span> </span>&#123;</span><br><span class="line">    TokenIdAndPublicURL urlAndToken = provider.get();</span><br><span class="line">    <span class="keyword">if</span> (input.url().indexOf(<span class="string">"http"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      input.insert(<span class="number">0</span>, urlAndToken.publicURL);</span><br><span class="line">    &#125;</span><br><span class="line">    input.header(<span class="string">"X-Auth-Token"</span>, urlAndToken.tokenId);</span><br><span class="line">    input.header(<span class="string">"X-Request-ID"</span>, requestIdProvider.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Bank bank = Feign.builder()</span><br><span class="line">        .target(<span class="keyword">new</span> DynamicAuthTokenTarget(Bank.class, provider, requestIdProvider));</span><br></pre></td></tr></table></figure></p><p>这种方法的实现依赖于给Feign 客户端设置的自定义的<code>RequestInterceptor</code> 或 <code>Target</code>。可以被用来给一个客户端的所有api请求设置请求头。比如说可是被用来在header中设置身份校验信息。这些方法是在线程执行api请求的时候才会执行，所以是允许在运行时根据上下文来动态设置header的。<br>比如说可以根据线程本地存储(thread-local storage)来为不同的线程设置不同的请求头。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Base-APIS"><a href="#Base-APIS" class="headerlink" title="Base APIS"></a>Base APIS</h3><p>有些请求中的一些方法是通用的，但是可能会有不同的参数类型或者返回类型，这个时候可以这么用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用API</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /health"</span>)</span><br><span class="line">  <span class="function">String <span class="title">health</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /all"</span>)</span><br><span class="line">  <span class="function">List&lt;Entity&gt; <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承通用API</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomAPI</span> <span class="keyword">extends</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /custom"</span>)</span><br><span class="line">  <span class="function">String <span class="title">custom</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种类型有相同的表现形式，定义一个统一的API</span></span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"Accept: application/json"</span>)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /api"</span>)</span><br><span class="line">  <span class="function">List&lt;V&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"PUT /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String key, V value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的类型来继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Foo</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BarApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Bar</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>你可以通过设置一个 <code>Logger</code> 来记录http消息，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .logger(<span class="keyword">new</span> Logger.JavaLogger().appendToFile(<span class="string">"logs/http.log"</span>))</span><br><span class="line">                     .logLevel(Logger.Level.FULL)</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure></p><p>也可以参考上面的 SLF4J 章节的说明</p><h3 id="Request-Interceptors"><a href="#Request-Interceptors" class="headerlink" title="Request Interceptors"></a>Request Interceptors</h3><p>当你希望修改所有的的请求的时候，你可以使用<code>Request Interceptors</code>。比如说，你作为一个中介，你可能需要为每个请求设置 <code>X-Forwarded-For</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardedForInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">    template.header(<span class="string">"X-Forwarded-For"</span>, <span class="string">"origin.host.com"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> ForwardedForInterceptor())</span><br><span class="line">                 .target(Bank.class, <span class="string">"https://api.examplebank.com"</span>);</span><br></pre></td></tr></table></figure></p><p>或者，你可能需要实现Basic Auth，这里有一个内置的基础校验拦截器 <code>BasicAuthRequestInterceptor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(username, password))</span><br><span class="line">                 .target(Bank.class, <span class="string">"https://api.examplebank.com"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="Custom-Param-Expansion"><a href="#Custom-Param-Expansion" class="headerlink" title="Custom @Param Expansion"></a>Custom @Param Expansion</h3><p>在使用 <code>@Param</code> 注解给模板中的参数设值的时候，默认的是使用的对象的 <code>toString()</code> 方法的值，通过声明 自定义的<code>Param.Expander</code>，用户可以控制其行为，比如说格式化 <code>Date</code> 类型的值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置 @Param 的 expander 为 DateToMillis.class 可以定义Date类型的值</span></span><br><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"GET /?since=&#123;date&#125;"</span>)</span><br><span class="line"><span class="function">Result <span class="title">list</span><span class="params">(@Param(value = <span class="string">"date"</span>, expander = DateToMillis.class)</span> Date date)</span>;</span><br></pre></td></tr></table></figure></p><h3 id="Dynamic-Query-Parameters"><a href="#Dynamic-Query-Parameters" class="headerlink" title="Dynamic Query Parameters"></a>Dynamic Query Parameters</h3><p>动态查询参数支持，通过使用 <code>@QueryMap</code> 可以允许动态传入请求参数,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"GET /find"</span>)</span><br><span class="line"><span class="function">V <span class="title">find</span><span class="params">(@QueryMap Map&lt;String, Object&gt; queryMap)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="Static-and-Default-Methods"><a href="#Static-and-Default-Methods" class="headerlink" title="Static and Default Methods"></a>Static and Default Methods</h3><p>如果你使用的是JDK 1.8+ 的话，那么你可以给接口设置统一的默认方法和静态方法,这个事JDK8的新特性，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /users/&#123;username&#125;/repos?sort=&#123;sort&#125;"</span>)</span><br><span class="line">  <span class="function">List&lt;Repo&gt; <span class="title">repos</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"sort"</span>)</span> String sort)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Repo&gt; <span class="title">repos</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repos(owner, <span class="string">"full_name"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lists all contributors for all repos owned by a user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">    MergingContributorList contributors = <span class="keyword">new</span> MergingContributorList();</span><br><span class="line">    <span class="keyword">for</span>(Repo repo : <span class="keyword">this</span>.repos(owner)) &#123;</span><br><span class="line">      contributors.addAll(<span class="keyword">this</span>.contributors(user, repo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contributors.mergeResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GitHub <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Feign.builder()</span><br><span class="line">                .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>英文原文请参考:<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a><br>翻译参考:<a href="https://blog.csdn.net/u010862794/article/details/73649616" target="_blank" rel="noopener">https://blog.csdn.net/u010862794/article/details/73649616</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Feign是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Retrofit&lt;/a&gt;, &lt;a href=&quot;https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAXRS-2.0&lt;/a&gt;和&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebSocket&lt;/a&gt;。Feign 最初是为了降低统一绑定&lt;a href=&quot;https://github.com/Netflix/Denominator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Denominator&lt;/a&gt; 到 HTTP API 的复杂度，不区分是否支持 &lt;a href=&quot;http://www.slideshare.net/adrianfcole/99problems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReSTfulness&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么选择Feign而不是其他&quot;&gt;&lt;a href=&quot;#为什么选择Feign而不是其他&quot; class=&quot;headerlink&quot; title=&quot;为什么选择Feign而不是其他&quot;&gt;&lt;/a&gt;为什么选择Feign而不是其他&lt;/h2&gt;&lt;p&gt;你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。你也可以直接使用 Apache HttpClient 来实现。但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="http" scheme="http://techblog.ppdai.com/tags/http/"/>
    
      <category term="rest" scheme="http://techblog.ppdai.com/tags/rest/"/>
    
      <category term="feign" scheme="http://techblog.ppdai.com/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>feign源码解析</title>
    <link href="http://techblog.ppdai.com/2018/05/14/20180514/"/>
    <id>http://techblog.ppdai.com/2018/05/14/20180514/</id>
    <published>2018-05-14T11:43:21.000Z</published>
    <updated>2018-05-15T06:26:48.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="feign介绍"><a href="#feign介绍" class="headerlink" title="feign介绍"></a>feign介绍</h2><p><a href="https://github.com/OpenFeign/feign/" target="_blank" rel="noopener">Feign</a>是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>, <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html" target="_blank" rel="noopener">JAXRS-2.0</a>和<a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="noopener">WebSocket</a>。feign在github上有近3K个star，是一款相当优秀的开源组件，虽然相比Retrofit的近30K个star，逊色了太多，但是spring cloud集成了feign，使得feign在java生态中比Retrofit使用的更加广泛。</p><p>feign的基本原理是在接口方法上加注解，定义rest请求，构造出接口的动态代理对象，然后通过调用接口方法就可以发送http请求，并且自动解析http响应为方法返回值，极大的简化了客户端调用rest api的代码。官网的示例如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">  String login;</span><br><span class="line">  <span class="keyword">int</span> contributions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  GitHub github = Feign.builder()</span><br><span class="line">                       .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                       .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">  List&lt;Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">  <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">    System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feign使用教程请参考官网<a href="https://github.com/OpenFeign/feign/" target="_blank" rel="noopener">https://github.com/OpenFeign/feign/</a></p><p>本文主要是对feign源码进行分析，根据源码来理解feign的设计架构和内部实现技术。  </p><h2 id="Feign-build构建接口动态代理"><a href="#Feign-build构建接口动态代理" class="headerlink" title="Feign.build构建接口动态代理"></a>Feign.build构建接口动态代理</h2><p>我们先来看看接口的动态代理是如何构建出来的，下图是主要接口和类的类图：</p><p><img src="/2018/05/14/20180514/init1.png" alt=""></p><p>从上文中的示例可以看到，构建的接口动态代理对象是通过<code>Feign.builder()</code>生成<code>Feign.Builder</code>的构造者对象，然后设置相关的参数，再调用target方法构造的。<code>Feign.Builder</code>的参数包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//拦截器，组装完RequestTemplate，发请求之前的拦截处理RequestTemplate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;RequestInterceptor&gt; requestInterceptors = <span class="keyword">new</span> ArrayList&lt;RequestInterceptor&gt;();</span><br><span class="line"><span class="comment">//日志级别</span></span><br><span class="line">    <span class="keyword">private</span> Logger.Level logLevel = Logger.Level.NONE;</span><br><span class="line"><span class="comment">//契约模型，默认为Contract.Default，用户创建MethodMetadata，用spring cloud就是扩展这个实现springMVC注解</span></span><br><span class="line">    <span class="keyword">private</span> Contract contract = <span class="keyword">new</span> Contract.Default();</span><br><span class="line"><span class="comment">//客户端，默认为Client.Default，可以扩展ApacheHttpClient，OKHttpClient，RibbonClient等</span></span><br><span class="line">    <span class="keyword">private</span> Client client = <span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//重试设置，默认不设置</span></span><br><span class="line">    <span class="keyword">private</span> Retryer retryer = <span class="keyword">new</span> Retryer.Default();</span><br><span class="line"><span class="comment">//日志，可以接入Slf4j</span></span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="keyword">new</span> NoOpLogger();</span><br><span class="line"><span class="comment">//编码器，用于body的编码</span></span><br><span class="line">    <span class="keyword">private</span> Encoder encoder = <span class="keyword">new</span> Encoder.Default();</span><br><span class="line"><span class="comment">//解码器，用户response的解码</span></span><br><span class="line">    <span class="keyword">private</span> Decoder decoder = <span class="keyword">new</span> Decoder.Default();</span><br><span class="line"><span class="comment">//用@QueryMap注解的参数编码器</span></span><br><span class="line">    <span class="keyword">private</span> QueryMapEncoder queryMapEncoder = <span class="keyword">new</span> QueryMapEncoder.Default();</span><br><span class="line"><span class="comment">//请求错误解码器</span></span><br><span class="line">    <span class="keyword">private</span> ErrorDecoder errorDecoder = <span class="keyword">new</span> ErrorDecoder.Default();</span><br><span class="line"><span class="comment">//参数配置，主要是超时时间之类的</span></span><br><span class="line">    <span class="keyword">private</span> Options options = <span class="keyword">new</span> Options();</span><br><span class="line"><span class="comment">//动态代理工厂</span></span><br><span class="line">    <span class="keyword">private</span> InvocationHandlerFactory invocationHandlerFactory = <span class="keyword">new</span> InvocationHandlerFactory.Default();</span><br><span class="line"><span class="comment">//是否decode404</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> decode404;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closeAfterDecode = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>这块是一个典型的构造者模式，<code>target</code>方法内部先调用<code>build</code>方法新建一个<code>ReflectFeign</code>对象，然后调用<code>ReflectFeign</code>的<code>newInstance</code>方法创建动态代理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//默认使用HardCodedTarget</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Class&lt;T&gt; apiType, String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target(<span class="keyword">new</span> HardCodedTarget&lt;T&gt;(apiType, url));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">        <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                             logLevel, decode404, closeAfterDecode);</span><br><span class="line">    ParseHandlersByName handlersByName =</span><br><span class="line">        <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">                                errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">    <span class="comment">//handlersByName将所有参数进行封装，并提供解析接口方法的逻辑</span></span><br><span class="line">    <span class="comment">//invocationHandlerFactory是Builder的属性，默认值是InvocationHandlerFactory.Default,用创建java动态代理的InvocationHandler实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectiveFeign</code>构造函数有三个参数：</p><ul><li><code>ParseHandlersByName</code> 将builder所有参数进行封装，并提供解析接口方法的逻辑</li><li><code>InvocationHandlerFactory</code> java动态代理的<code>InvocationHandler</code>的工厂类，默认值是<code>InvocationHandlerFactory.Default</code></li><li><code>QueryMapEncoder</code>  接口参数注解<code>@QueryMap</code>时，参数的编码器</li></ul><p><code>ReflectiveFeign.newInstance</code>方法创建接口动态代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//targetToHandlersByName是构造器传入的ParseHandlersByName对象，根据target对象生成MethodHandler映射</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">//遍历接口所有方法，构建Method-&gt;MethodHandler的映射</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      <span class="comment">//接口default方法的Handler，这类方法直接调用</span></span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里factory是构造其中传入的，创建InvocationHandler</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  <span class="comment">//java的动态代理</span></span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line">  <span class="comment">//将default方法直接绑定到动态代理上</span></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码主要的逻辑是：</p><ol><li>创建<code>MethodHandler</code>的映射，这里创建的是实现类<code>SynchronousMethodHandler</code></li><li>通过<code>InvocationHandlerFatory</code>创建<code>InvocationHandler</code></li><li>绑定接口的<code>default</code>方法，通过<code>DefaultMethodHandler</code>绑定</li></ol><p>类图中已经画出，<code>SynchronousMethodHandler</code>和<code>DefaultMethodHandler</code>实现了<code>InvocationHandlerFactory.MethodHandler</code>接口，动态代理对象调用方法时，如果是<code>default</code>方法，会直接调用接口方法，因为这里将接口的<code>default</code>方法绑定到动态代理对象上了，其他方法根据方法签名找到<code>SynchronousMethodHandler</code>对象，调用其<code>invoke</code>方法。</p><h2 id="创建MethodHandler方法处理器"><a href="#创建MethodHandler方法处理器" class="headerlink" title="创建MethodHandler方法处理器"></a>创建MethodHandler方法处理器</h2><p><code>SynchronousMethodHandler</code>是feign组件的核心，接口方法调用转换为http请求和解析http响应都是通过<code>SynchronousMethodHandler</code>来执行的，相关类图如下：</p><p><img src="/2018/05/14/20180514/init2.png" alt=""></p><p>创建<code>MethodHandler</code>实现类<code>SynchronousMethodHandler</code>的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过contract解析接口方法，生成MethodMetadata列表，默认的contract解析Feign自定义的http注解</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    <span class="comment">//BuildTemplateByResolvingArgs实现RequestTemplate.Factory，RequestTemplate的工厂</span></span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="comment">//根据方法元数据，使用不同的RequestTemplate的工厂</span></span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果有formParam，并且bodyTemplate不为空，请求体为x-www-form-urlencoded格式</span></span><br><span class="line">      <span class="comment">//将会解析form参数，填充到bodyTemplate中</span></span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果包含请求体，将会用encoder编码请求体对象</span></span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//默认的RequestTemplate的工厂，没有请求体，不需要编码器</span></span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用工厂SynchronousMethodHandler.Factory创建SynchronousMethodHandler</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的逻辑是：</p><ol><li>通过<code>Contract</code>解析接口方法，生成<code>MethodMetadata</code>，默认的<code>Contract</code>解析Feign自定义的http注解</li><li>根据<code>MethodMetadata</code>方法元数据生成特定的<code>RequestTemplate</code>的工厂</li><li>使用<code>SynchronousMethodHandler.Factory</code>工厂创建<code>SynchronousMethodHandler</code><br>这里有两个工厂不要搞混淆了，<code>SynchronousMethodHandler</code>工厂和<code>RequestTemplate</code>工厂，<code>SynchronousMethodHandler</code>的属性包含<code>RequestTemplate</code>工厂</li></ol><h2 id="Contract解析接口方法生成MethodMetadata"><a href="#Contract解析接口方法生成MethodMetadata" class="headerlink" title="Contract解析接口方法生成MethodMetadata"></a>Contract解析接口方法生成MethodMetadata</h2><p>feign默认的解析器是<code>Contract.Default</code>继承了<code>Contract.BaseContract</code>，解析生成<code>MethodMetadata</code>方法入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MethodMetadata&gt; <span class="title">parseAndValidatateMetadata</span><span class="params">(Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  Map&lt;String, MethodMetadata&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodMetadata&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Method method : targetType.getMethods()) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    MethodMetadata metadata = parseAndValidateMetadata(targetType, method);</span><br><span class="line">    。。。</span><br><span class="line">    result.put(metadata.configKey(), metadata);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;MethodMetadata&gt;(result.values());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MethodMetadata <span class="title">parseAndValidateMetadata</span><span class="params">(Class&lt;?&gt; targetType, Method method)</span> </span>&#123;</span><br><span class="line">  MethodMetadata data = <span class="keyword">new</span> MethodMetadata();</span><br><span class="line">  data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));</span><br><span class="line">  data.configKey(Feign.configKey(targetType, method));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(targetType.getInterfaces().length == <span class="number">1</span>) &#123;</span><br><span class="line">    processAnnotationOnClass(data, targetType.getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理Class上的注解</span></span><br><span class="line">  processAnnotationOnClass(data, targetType);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;</span><br><span class="line">    <span class="comment">//处理方法注解</span></span><br><span class="line">    processAnnotationOnMethod(data, methodAnnotation, method);</span><br><span class="line">  &#125;</span><br><span class="line">  。。。</span><br><span class="line">  Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">  Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">//方法参数注解</span></span><br><span class="line">  Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">int</span> count = parameterAnnotations.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameterAnnotations[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">      isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes[i] == URI.class) &#123;</span><br><span class="line">      <span class="comment">//参数类型是URI，后面构造http请求时，使用该URI</span></span><br><span class="line">      data.urlIndex(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isHttpAnnotation) &#123;</span><br><span class="line">      <span class="comment">//如果没有被http注解，就是body参数</span></span><br><span class="line">      。。。</span><br><span class="line">      data.bodyIndex(i);</span><br><span class="line">      data.bodyType(Types.resolve(targetType, targetType, genericParameterTypes[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.headerMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//@HeaderMap注解的参数必须是Map，key类型必须是String</span></span><br><span class="line">    checkMapString(<span class="string">"HeaderMap"</span>, parameterTypes[data.headerMapIndex()], genericParameterTypes[data.headerMapIndex()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.queryMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Map.class.isAssignableFrom(parameterTypes[data.queryMapIndex()])) &#123;</span><br><span class="line">      <span class="comment">//@QueryMap注解的参数如果是Map，key类型必须是String</span></span><br><span class="line">      checkMapKeys(<span class="string">"QueryMap"</span>, genericParameterTypes[data.queryMapIndex()]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata data, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (targetType.isAnnotationPresent(Headers.class)) &#123;</span><br><span class="line">    <span class="comment">//被Headers注解</span></span><br><span class="line">    String[] headersOnType = targetType.getAnnotation(Headers.class).value();</span><br><span class="line">    。。。</span><br><span class="line">    <span class="comment">//header解析成map，加到MethodMetadata中</span></span><br><span class="line">    Map&lt;String, Collection&lt;String&gt;&gt; headers = toMap(headersOnType);</span><br><span class="line">    headers.putAll(data.template().headers());</span><br><span class="line">    data.template().headers(<span class="keyword">null</span>); <span class="comment">// to clear</span></span><br><span class="line">    data.template().headers(headers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data, Annotation methodAnnotation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Method method)</span> </span>&#123;</span><br><span class="line">  Class&lt;? extends Annotation&gt; annotationType = methodAnnotation.annotationType();</span><br><span class="line">  <span class="keyword">if</span> (annotationType == RequestLine.class) &#123;</span><br><span class="line">    <span class="comment">//@RequestLine注解</span></span><br><span class="line">    String requestLine = RequestLine.class.cast(methodAnnotation).value();</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (requestLine.indexOf(<span class="string">' '</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">      。。。</span><br><span class="line">      data.template().method(requestLine);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//http请求方法</span></span><br><span class="line">    data.template().method(requestLine.substring(<span class="number">0</span>, requestLine.indexOf(<span class="string">' '</span>)));</span><br><span class="line">    <span class="keyword">if</span> (requestLine.indexOf(<span class="string">' '</span>) == requestLine.lastIndexOf(<span class="string">' '</span>)) &#123;</span><br><span class="line">      <span class="comment">// no HTTP version is ok</span></span><br><span class="line">      data.template().append(requestLine.substring(requestLine.indexOf(<span class="string">' '</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// skip HTTP version</span></span><br><span class="line">      data.template().append(</span><br><span class="line">          requestLine.substring(requestLine.indexOf(<span class="string">' '</span>) + <span class="number">1</span>, requestLine.lastIndexOf(<span class="string">' '</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将'%2F'反转为'/'</span></span><br><span class="line">    data.template().decodeSlash(RequestLine.class.cast(methodAnnotation).decodeSlash());</span><br><span class="line">    <span class="comment">//参数集合格式化方式，默认使用key=value0&amp;key=value1</span></span><br><span class="line">    data.template().collectionFormat(RequestLine.class.cast(methodAnnotation).collectionFormat());</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == Body.class) &#123;</span><br><span class="line">    <span class="comment">//@Body注解</span></span><br><span class="line">    String body = Body.class.cast(methodAnnotation).value();</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (body.indexOf(<span class="string">'&#123;'</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//body中不存在&#123;，直接传入body</span></span><br><span class="line">      data.template().body(body);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//body中存在&#123;，就是bodyTemplate方式</span></span><br><span class="line">      data.template().bodyTemplate(body);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == Headers.class) &#123;</span><br><span class="line">    <span class="comment">//@Header注解</span></span><br><span class="line">    String[] headersOnMethod = Headers.class.cast(methodAnnotation).value();</span><br><span class="line">    。。。</span><br><span class="line">    data.template().headers(toMap(headersOnMethod));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理参数上的注解</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata data, Annotation[] annotations, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();</span><br><span class="line">    <span class="keyword">if</span> (annotationType == Param.class) &#123;</span><br><span class="line">      <span class="comment">//@Param注解</span></span><br><span class="line">      Param paramAnnotation = (Param) annotation;</span><br><span class="line">      String name = paramAnnotation.value();</span><br><span class="line">      。。。</span><br><span class="line">      <span class="comment">//增加到MethodMetadata中</span></span><br><span class="line">      nameParam(data, name, paramIndex);</span><br><span class="line">      <span class="comment">//@Param注解的expander参数，定义参数的解释器，默认是ToStringExpander，调用参数的toString方法</span></span><br><span class="line">      Class&lt;? extends Param.Expander&gt; expander = paramAnnotation.expander();</span><br><span class="line">      <span class="keyword">if</span> (expander != Param.ToStringExpander.class) &#123;</span><br><span class="line">        data.indexToExpanderClass().put(paramIndex, expander);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//参数是否已经urlEncoded，如果没有，会使用urlEncoded方式编码</span></span><br><span class="line">      data.indexToEncoded().put(paramIndex, paramAnnotation.encoded());</span><br><span class="line">      isHttpAnnotation = <span class="keyword">true</span>;</span><br><span class="line">      String varName = <span class="string">'&#123;'</span> + name + <span class="string">'&#125;'</span>;</span><br><span class="line">      <span class="keyword">if</span> (!data.template().url().contains(varName) &amp;&amp;</span><br><span class="line">          !searchMapValuesContainsSubstring(data.template().queries(), varName) &amp;&amp;</span><br><span class="line">          !searchMapValuesContainsSubstring(data.template().headers(), varName)) &#123;</span><br><span class="line">        <span class="comment">//如果参数不在path里面，不在query里面，不在header里面，就设置到formParam中</span></span><br><span class="line">        data.formParams().add(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == QueryMap.class) &#123;</span><br><span class="line">      <span class="comment">//@QueryMap注解，注解参数对象时，将该参数转换为http请求参数格式发送</span></span><br><span class="line">      。。。</span><br><span class="line">      data.queryMapIndex(paramIndex);</span><br><span class="line">      data.queryMapEncoded(QueryMap.class.cast(annotation).encoded());</span><br><span class="line">      isHttpAnnotation = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == HeaderMap.class) &#123;</span><br><span class="line">      <span class="comment">//@HeaderMap注解，注解一个Map类型的参数，放入http header中发送</span></span><br><span class="line">      。。。</span><br><span class="line">      data.headerMapIndex(paramIndex);</span><br><span class="line">      isHttpAnnotation = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isHttpAnnotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码稍微有点多，但是逻辑很清晰，先处理类上的注解，再处理方法上注解，最后处理方法参数注解，把所有注解的情况都处理到就可以了。  </p><p>生成的<code>MethodMetadata</code>的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodMetadata</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//标识方法的key，接口名加方法签名：GitHub#contributors(String,String)</span></span><br><span class="line">  <span class="keyword">private</span> String configKey;</span><br><span class="line"><span class="comment">//方法返回值类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Type returnType;</span><br><span class="line"><span class="comment">//uri参数的位置，方法中可以写个uri参数，发请求时直接使用这个参数</span></span><br><span class="line">  <span class="keyword">private</span> Integer urlIndex;</span><br><span class="line"><span class="comment">//body参数的位置，只能有一个未注解的参数为body，否则报错</span></span><br><span class="line">  <span class="keyword">private</span> Integer bodyIndex;</span><br><span class="line"><span class="comment">//headerMap参数的位置</span></span><br><span class="line">  <span class="keyword">private</span> Integer headerMapIndex;</span><br><span class="line"><span class="comment">//@QueryMap注解参数位置</span></span><br><span class="line">  <span class="keyword">private</span> Integer queryMapIndex;</span><br><span class="line"><span class="comment">//@QueryMap注解里面encode参数，是否已经urlEncode编码过了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> queryMapEncoded;</span><br><span class="line"><span class="comment">//body的类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Type bodyType;</span><br><span class="line"><span class="comment">//RequestTemplate 原型</span></span><br><span class="line">  <span class="keyword">private</span> RequestTemplate template = <span class="keyword">new</span> RequestTemplate();</span><br><span class="line"><span class="comment">//form请求参数</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; formParams = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//方法参数位置和名称的map</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Collection&lt;String&gt;&gt; indexToName ;</span><br><span class="line"><span class="comment">//@Param中注解的expander方法，可以指定解析参数类</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Class&lt;? extends Expander&gt;&gt; indexToExpanderClass ;</span><br><span class="line"><span class="comment">//参数是否被urlEncode编码过了，@Param中encoded方法</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Boolean&gt; indexToEncoded ;</span><br><span class="line"><span class="comment">//自定义的Expander</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;Integer, Expander&gt; indexToExpander;</span><br></pre></td></tr></table></figure><blockquote><p><code>Contract也</code>是feign的一个扩展点，一个优秀组件的架构通常是具有很强的扩展性，feign的架构本身很简单，设计的扩展点也很简单方便，所以受到spring的青睐，将其集成到spring cloud中。spring cloud就是通过<code>Contract</code>的扩展，实现使用springMVC的注解接入feign。feign自己还实现了使用jaxrs注解接入feign。</p></blockquote><h2 id="初始化总结"><a href="#初始化总结" class="headerlink" title="初始化总结"></a>初始化总结</h2><p>上文已经完成了feign初始化结构为动态代理的整个过程，简单的捋一遍：</p><ol><li>初始化<code>Feign.Builder</code>传入参数，构造<code>ReflectiveFeign</code></li><li><code>ReflectiveFeign</code>通过内部类<code>ParseHandlersByName</code>的<code>Contract</code>属性，解析接口生成<code>MethodMetadata</code></li><li><code>ParseHandlersByName</code>根据<code>MethodMetadata</code>生成<code>RequestTemplate</code>工厂</li><li><code>ParseHandlersByName</code>创建<code>SynchronousMethodHandler</code>，传入<code>MethodMetadata</code>、<code>RequestTemplate</code>工厂和<code>Feign.Builder</code>相关参数</li><li><code>ReflectiveFeign</code>创建<code>FeignInvocationHandler</code>，传入参数<code>SynchronousMethodHandler</code>，绑定<code>DefaultMethodHandler</code></li><li><code>ReflectiveFeign</code>根据<code>FeignInvocationHandler</code>创建<code>Proxy</code></li></ol><p>关键的几个类是：</p><ul><li><code>ReflectiveFeign</code> 初始化入口</li><li><code>FeignInvocationHandler</code> 实现动态代理的<code>InvocHandler</code></li><li><code>SynchronousMethodHandler</code> 方法处理器，方法调用处理器</li><li><code>MethodMetadata</code> 方法元数据</li></ul><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>为方便理解，分析完feign源码后，我将feign执行过程分成三层，如下图：</p><p><img src="/2018/05/14/20180514/execute.png" alt=""></p><p>三层分别为：</p><ul><li>代理层 动态代理调用层</li><li>转换层 方法转http请求，解码http响应</li><li>网络层 http请求发送</li></ul><p>java动态代理接口方法调用，会调用到<code>InvocaHandler</code>的invoke方法，feign里面实现类是<code>FeignInvocationHandler</code>，invoke代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法找到<code>MethodHandler</code>，除接口的<code>default</code>方法外，找到的是<code>SynchronousMethodHandler</code>对象，然后调用<code>SynchronousMethodHandlerd.invoke</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//buildTemplateFromArgs是RequestTemplate工程对象，根据方法参数创建RequestTemplate</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">//重试设置</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行和解码</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      。。。</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//RequestTemplate转换为Request</span></span><br><span class="line">  Request request = targetRequest(template)</span><br><span class="line">  。。。</span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="comment">//如果接口方法返回的是Response类</span></span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//body为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">              response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        <span class="comment">//body不为空，且length&gt;最大缓存值，返回response，但是不能关闭response</span></span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读取body字节数组，返回response</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="comment">//响应成功</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="comment">//接口返回void</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//解码response，直接调用decoder解码</span></span><br><span class="line">        Object result = decode(response);</span><br><span class="line">        shouldClose = closeAfterDecode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      <span class="comment">//404解析</span></span><br><span class="line">      Object result = decode(response);</span><br><span class="line">      shouldClose = closeAfterDecode;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//其他返回码，使用errorDecoder解析，抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//是否需要关闭response，根据Feign.Builder 参数设置是否要关闭流</span></span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程比较简单，生成<code>RquestTemplate</code> -&gt; 转换为<code>Request</code> -&gt; <code>client</code>发请求 -&gt; <code>Decoder</code>解析<code>Response</code></p><h2 id="RquestTemplate构建过程"><a href="#RquestTemplate构建过程" class="headerlink" title="RquestTemplate构建过程"></a>RquestTemplate构建过程</h2><p>先看看<code>RequestTemplate</code>的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//请求参数 ?后面的name=value</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; queries ;</span><br><span class="line"><span class="comment">//请求头</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; headers ;</span><br><span class="line"><span class="comment">//请求方法 GET/POST等</span></span><br><span class="line">  <span class="keyword">private</span> String method;</span><br><span class="line"><span class="comment">//请求路径</span></span><br><span class="line">  <span class="keyword">private</span> StringBuilder url = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//字符集</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Charset charset;</span><br><span class="line"><span class="comment">//请求体</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"><span class="comment">//@Body("%7B\"user_name\": \"&#123;user_name&#125;\", \"password\": \"&#123;password&#125;\"%7D")注解的模板</span></span><br><span class="line">  <span class="keyword">private</span> String bodyTemplate;</span><br><span class="line"><span class="comment">//是否decode削减，将"%2F"反转为"/"</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> decodeSlash = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//集合格式化，分隔符</span></span><br><span class="line">  <span class="keyword">private</span> CollectionFormat collectionFormat = CollectionFormat.EXPLODED;</span><br></pre></td></tr></table></figure></p><p>在<code>SynchronousMethodHandler.invoke</code>方法中生成<code>RequestTemplate</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildTemplateFromArgs是RequestTemplate.Factory实现类</span></span><br><span class="line">RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br></pre></td></tr></table></figure></p><p><code>RequestTemplate.Factory</code>有三个实现类：</p><ul><li><code>BuildTemplateByResolvingArgs</code> <code>RequestTemplate</code>工厂</li><li><code>BuildEncodedTemplateFromArgs</code> <code>BuildTemplateByResolvingArgs</code>的子类 重载<code>resolve</code>方法，解析form表单请求</li><li><code>BuildFormEncodedTemplateFromArgs</code> <code>BuildTemplateByResolvingArgs</code>的子类，重载<code>resolve</code>方法，解析body请求</li></ul><p><code>BuildTemplateByResolvingArgs</code>创建<code>RequestTemplate</code>的<code>create</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BuildTemplateByResolvingArgs实现RequestTemplate.Factory的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestTemplate <span class="title">create</span><span class="params">(Object[] argv)</span> </span>&#123;</span><br><span class="line">  RequestTemplate mutable = <span class="keyword">new</span> RequestTemplate(metadata.template());</span><br><span class="line">  <span class="keyword">if</span> (metadata.urlIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//插入接口方法参数中的URI</span></span><br><span class="line">    <span class="keyword">int</span> urlIndex = metadata.urlIndex();</span><br><span class="line">    mutable.insert(<span class="number">0</span>, String.valueOf(argv[urlIndex]));</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;String, Object&gt; varBuilder = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  <span class="comment">//方法参数位置和请求定义的参数名称的map</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, Collection&lt;String&gt;&gt; entry : metadata.indexToName().entrySet()) &#123;</span><br><span class="line">    <span class="comment">//将方法参数值和定义的请求参数进行映射，varBuilder</span></span><br><span class="line">    <span class="keyword">int</span> i = entry.getKey();</span><br><span class="line">    Object value = argv[entry.getKey()];</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123; <span class="comment">// Null values are skipped.</span></span><br><span class="line">      <span class="keyword">if</span> (indexToExpander.containsKey(i)) &#123;</span><br><span class="line">        value = expandElements(indexToExpander.get(i), value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String name : entry.getValue()) &#123;</span><br><span class="line">        varBuilder.put(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析RequestTemplate</span></span><br><span class="line">  RequestTemplate template = resolve(argv, mutable, varBuilder);</span><br><span class="line">  <span class="comment">//解析queryMap，这块代码有些奇怪，为什么单独把queryMap放在这里解析，而不是在resolve方法中，或者在RequestTemplate中</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.queryMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// add query map parameters after initial resolve so that they take</span></span><br><span class="line">    <span class="comment">// precedence over any predefined values</span></span><br><span class="line">    Object value = argv[metadata.queryMapIndex()];</span><br><span class="line">    Map&lt;String, Object&gt; queryMap = toQueryMap(value);</span><br><span class="line">    template = addQueryMapQueryParameters(queryMap, template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析headerMap定义的参数</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.headerMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    template = addHeaderMapHeaders((Map&lt;String, Object&gt;) argv[metadata.headerMapIndex()], template);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuildTemplateByResolvingArgs</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestTemplate <span class="title">resolve</span><span class="params">(Object[] argv, RequestTemplate mutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据需要进行urlEncode参数</span></span><br><span class="line">  Map&lt;String, Boolean&gt; variableToEncoded = <span class="keyword">new</span> LinkedHashMap&lt;String, Boolean&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, Boolean&gt; entry : metadata.indexToEncoded().entrySet()) &#123;</span><br><span class="line">    Collection&lt;String&gt; names = metadata.indexToName().get(entry.getKey());</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      variableToEncoded.put(name, entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析参数</span></span><br><span class="line">  <span class="keyword">return</span> mutable.resolve(variables, variableToEncoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuildEncodedTemplateFromArgs</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestTemplate <span class="title">resolve</span><span class="params">(Object[] argv, RequestTemplate mutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">  Object body = argv[metadata.bodyIndex()];</span><br><span class="line">  checkArgument(body != <span class="keyword">null</span>, <span class="string">"Body parameter %s was null"</span>, metadata.bodyIndex());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//编码并设置RequestTemplate的body</span></span><br><span class="line">    encoder.encode(body, metadata.bodyType(), mutable);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (EncodeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EncodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.resolve(argv, mutable, variables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuildFormEncodedTemplateFromArgs</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestTemplate <span class="title">resolve</span><span class="params">(Object[] argv, RequestTemplate mutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//构造form参数，为HashMap</span></span><br><span class="line">  Map&lt;String, Object&gt; formVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;String, Object&gt; entry : variables.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.formParams().contains(entry.getKey())) &#123;</span><br><span class="line">      formVariables.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//编码并设置RequestTemplate的body，</span></span><br><span class="line">    encoder.encode(formVariables, Encoder.MAP_STRING_WILDCARD, mutable);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (EncodeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EncodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用父类的resolve</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.resolve(argv, mutable, variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>RequestTemplate</code>解析参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestTemplate解析参数的方法</span></span><br><span class="line"><span class="function">RequestTemplate <span class="title">resolve</span><span class="params">(Map&lt;String, ?&gt; unencoded, Map&lt;String, Boolean&gt; alreadyEncoded)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//替换请求Query中的参数</span></span><br><span class="line">  replaceQueryValues(unencoded, alreadyEncoded);</span><br><span class="line">  Map&lt;String, String&gt; encoded = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;String, ?&gt; entry : unencoded.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">final</span> String key = entry.getKey();</span><br><span class="line">    <span class="keyword">final</span> Object objectValue = entry.getValue();</span><br><span class="line">    String encodedValue = encodeValueIfNotEncoded(key, objectValue, alreadyEncoded);</span><br><span class="line">    encoded.put(key, encodedValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析Url，替换path中的参数</span></span><br><span class="line">  String resolvedUrl = expand(url.toString(), encoded).replace(<span class="string">"+"</span>, <span class="string">"%20"</span>);</span><br><span class="line">  <span class="keyword">if</span> (decodeSlash) &#123;</span><br><span class="line">    resolvedUrl = resolvedUrl.replace(<span class="string">"%2F"</span>, <span class="string">"/"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  url = <span class="keyword">new</span> StringBuilder(resolvedUrl);</span><br><span class="line">  <span class="comment">//解析http请求的header</span></span><br><span class="line">  Map&lt;String, Collection&lt;String&gt;&gt; resolvedHeaders = <span class="keyword">new</span> LinkedHashMap&lt;String, Collection&lt;String&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String field : headers.keySet()) &#123;</span><br><span class="line">    Collection&lt;String&gt; resolvedValues = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String value : valuesOrEmpty(headers, field)) &#123;</span><br><span class="line">      String resolved = expand(value, unencoded);</span><br><span class="line">      resolvedValues.add(resolved);</span><br><span class="line">    &#125;</span><br><span class="line">    resolvedHeaders.put(field, resolvedValues);</span><br><span class="line">  &#125;</span><br><span class="line">  headers.clear();</span><br><span class="line">  headers.putAll(resolvedHeaders);</span><br><span class="line">  <span class="comment">//处理bodyTemplate</span></span><br><span class="line">  <span class="keyword">if</span> (bodyTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    body(urlDecode(expand(bodyTemplate, encoded)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工具方法，将含有&#123;varName&#125;的字符串模板中的变量名用变量值替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">expand</span><span class="params">(String template, Map&lt;String, ?&gt; variables)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (checkNotNull(template, <span class="string">"template"</span>).length() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(variables, <span class="string">"variables for %s"</span>, template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> inVar = <span class="keyword">false</span>;</span><br><span class="line">  StringBuilder var = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c : template.toCharArray()) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">        <span class="keyword">if</span> (inVar) &#123;</span><br><span class="line">          <span class="comment">// '&#123;&#123;' is an escape: write the brace and don't interpret as a variable</span></span><br><span class="line">          builder.append(<span class="string">"&#123;"</span>);</span><br><span class="line">          inVar = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inVar = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">        <span class="keyword">if</span> (!inVar) &#123; <span class="comment">// then write the brace literally</span></span><br><span class="line">          builder.append(<span class="string">'&#125;'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inVar = <span class="keyword">false</span>;</span><br><span class="line">        String key = var.toString();</span><br><span class="line">        Object value = variables.get(var.toString());</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          builder.append(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          builder.append(<span class="string">'&#123;'</span>).append(key).append(<span class="string">'&#125;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        var = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (inVar) &#123;</span><br><span class="line">          var.append(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          builder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="RquestTemplate转换Request"><a href="#RquestTemplate转换Request" class="headerlink" title="RquestTemplate转换Request"></a>RquestTemplate转换Request</h2><p>先来看看<code>Request</code>的结构，完整的http请求信息的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; headers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br></pre></td></tr></table></figure><p><code>SynchronousMethodHandler</code>的<code>targetRequest</code>方法将<code>RequestTemplate</code>转换为<code>Request</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先应用所用拦截器，拦截器是在Feign.Builder中传入的，拦截器可以修改RequestTemplate信息</span></span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用Target的apply方法，默认Target是HardCodedTarget</span></span><br><span class="line">  <span class="keyword">return</span> target.apply(<span class="keyword">new</span> RequestTemplate(template));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这块先应用所有拦截器，然后target的<code>apply</code>方法。拦截器和target都是扩展点，拦截器可以在构造好<code>RequestTemplate</code>后和发请求前修改请求信息，target默认使用<code>HardCodedTarget</code>直接发请求，feign还提供了<code>LoadBalancingTarget</code>，适配Ribbon来发请求，实现客户端的负载均衡。  </p><p>创建过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//HardCodedTarget的apply方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Request <span class="title">apply</span><span class="params">(RequestTemplate input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.url().indexOf(<span class="string">"http"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      input.insert(<span class="number">0</span>, url());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用RequestTemplate的request方法</span></span><br><span class="line">    <span class="keyword">return</span> input.request();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//RequestTemplate的request方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//安全拷贝所有header</span></span><br><span class="line">  Map&lt;String, Collection&lt;String&gt;&gt; safeCopy = <span class="keyword">new</span> LinkedHashMap&lt;String, Collection&lt;String&gt;&gt;();</span><br><span class="line">  safeCopy.putAll(headers);</span><br><span class="line">  <span class="comment">//调用Request的create静态方法</span></span><br><span class="line">  <span class="keyword">return</span> Request.create(</span><br><span class="line">      method, url + queryLine(),</span><br><span class="line">      Collections.unmodifiableMap(safeCopy),</span><br><span class="line">      body, charset</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Request的create方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">create</span><span class="params">(String method, String url, Map&lt;String, Collection&lt;String&gt;&gt; headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span>[] body, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request(method, url, headers, body, charset);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>从代码上可以看到，<code>RequestTemplate</code>基本上直接转为<code>Request</code>，没有做什么逻辑操作。对比下<code>LoadBalancingTarget</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Request apply(RequestTemplate input) &#123;</span><br><span class="line">  //选取一个Server，lb是Ribbon的AbstractLoadBalancer类</span><br><span class="line">  Server currentServer = lb.chooseServer(null);</span><br><span class="line">  //生成url</span><br><span class="line">  String url = format(&quot;%s://%s%s&quot;, scheme, currentServer.getHostPort(), path);</span><br><span class="line">  input.insert(0, url);</span><br><span class="line">  try &#123;</span><br><span class="line">    //生成Request</span><br><span class="line">    return input.request();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    lb.getLoadBalancerStats().incrementNumRequests(currentServer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，非常简单的几行代码，只要修改请求的url就能实现客户端负载均衡。</p><h2 id="http请求发送"><a href="#http请求发送" class="headerlink" title="http请求发送"></a>http请求发送</h2><p><code>SynchronousMethodHandler</code>中构造好<code>Request</code>后，直接调用client的<code>execute</code>方法发送请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = client.execute(request, options);</span><br></pre></td></tr></table></figure><p>client是一个<code>Client</code>接口，默认实现类是<code>Client.Default</code>，使用java api中的<code>HttpURLConnection</code>发送http请求。feign还实现了：</p><ul><li><code>ApacheHttpClient</code></li><li><code>OkHttpClient</code></li><li><code>RibbonClient</code><br>使用<code>RibbonClient</code>跟使用<code>LoadBalancingTarget</code>作用都是实现客户端负载均衡，<code>RibbonClient</code>实现稍微复杂些。</li></ul><h2 id="接口调用过程总结"><a href="#接口调用过程总结" class="headerlink" title="接口调用过程总结"></a>接口调用过程总结</h2><p>我们再将接口调用过程捋一遍：</p><p>1、接口的动态代理<code>Proxy</code>调用接口方法会执行的<code>FeignInvocationHandler</code><br>2、<code>FeignInvocationHandler</code>通过方法签名在属性<code>Map&lt;Method, MethodHandler&gt; dispatch</code>中找到<code>SynchronousMethodHandler</code>，调用<code>invoke</code>方法<br>3、<code>SynchronousMethodHandler</code>的<code>invoke</code>方法根据传入的方法参数，通过自身属性工厂对象<code>RequestTemplate.Factory</code>创建<code>RequestTemplate</code>，工厂里面会用根据需要进行<code>Encode</code><br>4、<code>SynchronousMethodHandler</code>遍历自身属性<code>RequestInterceptor</code>列表，对<code>RequestTemplate</code>进行改造<br>4、<code>SynchronousMethodHandler</code>调用自身<code>Target</code>属性的<code>apply</code>方法，将<code>RequestTemplate</code>转换为<code>Request</code>对象<br>5、<code>SynchronousMethodHandler</code>调用自身<code>Client</code>的<code>execute</code>方法，传入<code>Request</code>对象<br>6、<code>Client</code>将<code>Request</code>转换为<code>http</code>请求，发送后将http响应转换为<code>Response</code>对象<br>7、<code>SynchronousMethodHandler</code>调用<code>Decoder</code>的方法对<code>Response</code>对象解码后返回<br>8、返回的对象最后返回到<code>Proxy</code></p><p>时序图如下：<br><img src="/2018/05/14/20180514/execute-sequence.png" alt=""></p><h2 id="feign扩展点总结"><a href="#feign扩展点总结" class="headerlink" title="feign扩展点总结"></a>feign扩展点总结</h2><p>前文分析源代码时，已经提到了feign的扩展点，最后我们再将feign的主要扩展点进行总结一下：</p><ul><li><code>Contract</code> 契约<br><code>Contract</code>的作用是解析接口方法，生成Rest定义。feign默认使用自己的定义的注解，还提供了<ul><li><code>JAXRSContract</code> javax.ws.rs注解接口实现<br><code>SpringContract</code>是spring cloud提供SpringMVC注解实现方式。</li></ul></li></ul><ul><li><p><code>InvocationHandler</code> 动态代理handler<br>通过<code>InvocationHandlerFactory</code>注入到<code>Feign.Builder</code>中，feign提供了Hystrix的扩展，实现Hystrix接入</p></li><li><p><code>Encoder</code> 请求body编码器<br>feign已经提供扩展包含：</p><ul><li>默认编码器，只能处理String和byte[]</li><li>json编码器<code>GsonEncoder</code>、<code>JacksonEncoder</code></li><li>XML编码器<code>JAXBEncoder</code></li></ul></li></ul><ul><li><code>Decoder</code> http响应解码器<br>最基本的有：<ul><li>json解码器 <code>GsonDecoder</code>、<code>JacksonDecoder</code></li><li>XML解码器 <code>JAXBDecoder</code></li><li>Stream流解码器 <code>StreamDecoder</code></li></ul></li></ul><ul><li><code>Target</code> 请求转换器<br>feign提供的实现有：<ul><li><code>HardCodedTarget</code> 默认<code>Target</code>，不做任何处理。</li><li><code>LoadBalancingTarget</code> 使用Ribbon进行客户端路由</li></ul></li></ul><ul><li><code>Client</code> 发送http请求的客户端<br>feign提供的<code>Client</code>实现有：<ul><li><code>Client.Default</code> 默认实现，使用java api的<code>HttpClientConnection</code>发送http请求</li><li><code>ApacheHttpClient</code> 使用apache的Http客户端发送请求</li><li><code>OkHttpClient</code> 使用OKHttp客户端发送请求</li><li><code>RibbonClient</code> 使用Ribbon进行客户端路由</li></ul></li></ul><ul><li><p><code>RequestInterceptor</code> 请求拦截器<br>调用客户端发请求前，修改<code>RequestTemplate</code>，比如为所有请求添加Header就可以用拦截器实现。</p></li><li><p><code>Retryer</code> 重试策略<br>默认的策略是<code>Retryer.Default</code>，包含<code>3</code>个参数：间隔、最大间隔和重试次数，第一次失败重试前会sleep输入的间隔时间的，后面每次重试sleep时间是前一次的<code>1.5</code>倍，超过最大时间或者最大重试次数就失败</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;feign介绍&quot;&gt;&lt;a href=&quot;#feign介绍&quot; class=&quot;headerlink&quot; title=&quot;feign介绍&quot;&gt;&lt;/a&gt;feign介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OpenFeign/feign/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Feign&lt;/a&gt;是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Retrofit&lt;/a&gt;, &lt;a href=&quot;https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAXRS-2.0&lt;/a&gt;和&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebSocket&lt;/a&gt;。feign在github上有近3K个star，是一款相当优秀的开源组件，虽然相比Retrofit的近30K个star，逊色了太多，但是spring cloud集成了feign，使得feign在java生态中比Retrofit使用的更加广泛。&lt;/p&gt;
&lt;p&gt;feign的基本原理是在接口方法上加注解，定义rest请求，构造出接口的动态代理对象，然后通过调用接口方法就可以发送http请求，并且自动解析http响应为方法返回值，极大的简化了客户端调用rest api的代码。官网的示例如下：&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="http" scheme="http://techblog.ppdai.com/tags/http/"/>
    
      <category term="rest" scheme="http://techblog.ppdai.com/tags/rest/"/>
    
      <category term="feign" scheme="http://techblog.ppdai.com/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>微服务动态配置组件netflix archaius</title>
    <link href="http://techblog.ppdai.com/2018/05/08/20180508/"/>
    <id>http://techblog.ppdai.com/2018/05/08/20180508/</id>
    <published>2018-05-08T09:02:09.000Z</published>
    <updated>2018-05-15T06:23:25.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="archaius介绍"><a href="#archaius介绍" class="headerlink" title="archaius介绍"></a>archaius介绍</h2><p>archaius是Netflix公司开源项目之一，基于java的配置管理类库，主要用于多配置存储的动态获取。主要功能是对apache common configuration类库的扩展。在云平台开发中可以将其用作分布式配置管理依赖构件。同时，它有如下一些特性：</p><ul><li>动态获取属性</li><li>高效和线程安全的配置操作</li><li>配置改变时提供回调机制</li><li>可以通过jmx操作配置</li><li>复合配置</li></ul><a id="more"></a><p>官网给出的结构图：<br><img src="/2018/05/08/20180508/archaius.png" alt=""></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对于传统的单体应用，properties等配置文件可以解决配置问题，同时也可以通过maven profile配置来区别各个环境，但在一个几百上千节点的的微服务生态中，如何把每个微服务的配置文件都进行更新，并且很多时候还需要重启服务，是一件无法忍受的事情。<br>对于微服务架构而言，一个通用的配置中心是必不可少的。zookeeper、consul、etcd都可以作为集中的配置中心，但是他们的客户端api不是为配置而编写的，使用到配置场景时，会显得非常的臃肿，Archaius可以与这些配置中心结合，它提供的动态配置api，使用起来非常简单方便。<br>spring cloud的spring-cloud-netflix-core组件中集成了archaius，hystrix使用archaius动态修改各commandKey对应的参数（并发数和超时时间），用简单优雅的代码实现不重启生效配置项。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>在maven工程中加入依赖的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.netflix.archaius&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;archaius-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.7.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>archaius已经发展到2.x版本，但是spring cloud集成的还是0.7.X  </p><p>编写示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    //获取一个Long型的动态配置项，默认值是1000。</span><br><span class="line">    private static DynamicLongProperty timeToWait =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getLongProperty(&quot;lock.waitTime&quot;, 1000);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //设置回调</span><br><span class="line">        timeToWait.addCallback(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;timeToWait callback, new value: &quot; + timeToWait.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        //每秒将timeToWait动态配置值打印到控制台，timeToWait.get()会动态的获取最新的配置</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;timeToWait: &quot; + timeToWait.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>archaius默认读取classpath下的config.properties，所以在resources目录下增加config.properties文件，文件中增加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.waitTime=4</span><br></pre></td></tr></table></figure><p>然后运行Main，会在控制台打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timeToWait: 4</span><br><span class="line">timeToWait: 4</span><br><span class="line">timeToWait: 4</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p>让main继续运行，修改config.properties配置文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.waitTime=5</span><br></pre></td></tr></table></figure></p><p>重新编译工程，等待1分钟左右，控制台会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeToWait: 4</span><br><span class="line">timeToWait callback, new value: 5</span><br><span class="line">timeToWait: 5</span><br><span class="line">timeToWait: 5</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p>一分钟等得有点长，在启动main时加入VM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Darchaius.fixedDelayPollingScheduler.delayMills=2000 -Darchaius.fixedDelayPollingScheduler.initialDelayMills=2000</span><br></pre></td></tr></table></figure><p>只要修改config.properties配置文件，两秒后就能生效。</p><h2 id="api说明"><a href="#api说明" class="headerlink" title="api说明"></a>api说明</h2><h3 id="基本类型动态配置"><a href="#基本类型动态配置" class="headerlink" title="基本类型动态配置"></a>基本类型动态配置</h3><ul><li>DynamicFloatProperty</li><li>DynamicDoubleProperty</li><li>DynamicBooleanProperty</li><li>DynamicStringProperty</li><li>DynamicIntProperty</li><li>DynamicLongProperty</li></ul><p>类图如下：<br><img src="/2018/05/08/20180508/property.png" alt=""></p><p>基本类型的动态配置继承<code>PropertyWrapper</code>类，实现接口<code>Property</code>，方法说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Property&lt;T&gt; &#123;</span><br><span class="line">    //获取动态配置值</span><br><span class="line">    T getValue();</span><br><span class="line">    //获取默认值</span><br><span class="line">    T getDefaultValue();</span><br><span class="line">    //获取配置名</span><br><span class="line">    String getName();</span><br><span class="line">    //获取修改时间戳</span><br><span class="line">    long getChangedTimestamp();</span><br><span class="line">    //增加修改回调</span><br><span class="line">    void addCallback(Runnable callback);</span><br><span class="line">    //删除所有回调</span><br><span class="line">    void removeAllCallbacks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>DynamicPropertyFactory</code>的单例获取配置项实例</p><h3 id="扩展类型动态配置"><a href="#扩展类型动态配置" class="headerlink" title="扩展类型动态配置"></a>扩展类型动态配置</h3><ul><li><p>DynamicStringListProperty<br>可以动态配置String list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//String list</span><br><span class="line">DynamicStringListProperty prop = new DynamicStringListProperty(&quot;test2&quot;, &quot;0|1&quot;, &quot;\\|&quot;);</span><br><span class="line">List&lt;String&gt; list = prop.get();//获取包含&quot;0&quot;,&quot;1&quot;的字符串列表</span><br></pre></td></tr></table></figure></li><li><p>DynamicStringMapProperty<br>可以动态配置String Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//String map</span><br><span class="line">DynamicStringMapProperty prop = new DynamicStringMapProperty(&quot;test3&quot;, &quot;key1=1,key2=2,key3=3&quot;);</span><br><span class="line">Map&lt;String, String&gt; map = prop.get();</span><br></pre></td></tr></table></figure></li><li><p>DynamicStringSetProperty<br>可以动态配置String set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//String set</span><br><span class="line">DynamicStringSetProperty prop = new DynamicStringSetProperty(&quot;test4&quot;, &quot;a,b,c&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>这几个扩展类型内部有个<code>private DynamicStringProperty delegate;</code>属性，通过解析配置字符串创建需要的类型。</p><h3 id="变更回调"><a href="#变更回调" class="headerlink" title="变更回调"></a>变更回调</h3><p>动态配置项通过<code>addCallback</code>方法增加回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置回调</span><br><span class="line">timeToWait.addCallback(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;timeToWait callback, new value: &quot; + timeToWait.get());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="指定配置源"><a href="#指定配置源" class="headerlink" title="指定配置源"></a>指定配置源</h2><h3 id="指定配置文件名称"><a href="#指定配置文件名称" class="headerlink" title="指定配置文件名称"></a>指定配置文件名称</h3><p>archauis默认配置源是classpath下的config.properties，可以增加VM启动参数<br><code>-Darchaius.configurationSource.defaultFileName=test.properties</code>来修改文件名称</p><h3 id="指定配置url"><a href="#指定配置url" class="headerlink" title="指定配置url"></a>指定配置url</h3><p>通过启动参数：<br><code>-Darchaius.configurationSource.additionalUrls=file:///c:/config.properties,https://raw.githubusercontent.com/along101/spring-boot-test/master/actuator-test/src/main/resources/application.properties</code>指定配置源的url，以逗号分隔。<br>配置多个url相同配置项，后面的配置会覆盖前面的，classpath下配置文件优先级最低。</p><h2 id="spring-boot集成"><a href="#spring-boot集成" class="headerlink" title="spring boot集成"></a>spring boot集成</h2><p>spring bean初始化完成，属性值从配置文件注入之后，如果修改配置文件，属性值是不会修改的。如果我们想在运行过程中动态的获取配置项，我们可以将spring的Environment注入到bean中，在代码逻辑中从Environment中获取配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br><span class="line">public void someMethod()&#123;</span><br><span class="line">  ...</span><br><span class="line">  String config = environment.getProperty(&quot;someConfig.name&quot;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码显得有些臃肿，并且性能也不高，因为environment是由多个配置源组合起来的。我们使用archaius动态配置就简单很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private DynamicStringProperty someConfig=DynamicPropertyFactory.getInstance().getStringProperty(&quot;someConfig.name&quot;, &quot;default&quot;);</span><br><span class="line">public void someMethod()&#123;</span><br><span class="line">  ...</span><br><span class="line">  String config = someConfig.get();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想参数变更后做些业务操作，archaius非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//某个bean的内部</span><br><span class="line">private DynamicStringProperty someConfig=DynamicPropertyFactory.getInstance().getStringProperty(&quot;someConfig.name&quot;, &quot;default&quot;);</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;</span><br><span class="line">  someConfig.addCallback(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;new value: &quot; + someConfig.get());</span><br><span class="line">            //业务代码</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>spring boot中如何集成archaius呢？ spring-cloud-netflix-core自动配置了archaius，集成spring boot，只要加入如下依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-netflix-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.archaius&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;archaius-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>编写测试类TestApplication验证:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class TestApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ArchaiusAutoConfiguration archaiusAutoConfiguration;</span><br><span class="line"></span><br><span class="line">    private static final DynamicStringProperty archaiusTest =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getStringProperty(&quot;archaius.test&quot;, &quot;test1&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;env config: &quot; + env.getProperty(&quot;archaius.test&quot;));</span><br><span class="line">        System.out.println(&quot;archaius config: &quot; + archaiusTest.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在spring boot配置文件中加入配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archaius.test=archaius-test</span><br></pre></td></tr></table></figure></p><p>运行测试类TestApplication，会在控制台打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env config: archaius-test</span><br><span class="line">archaius config: archaius-test</span><br></pre></td></tr></table></figure></p><p>说明archaius从spring 的env中拿到配置了。  </p><p>但是这里有个问题，spring boot本身使用了外部配置，比如集成了apollo，<strong>修改配置，archaius配置项是不生效的</strong>。分析spring-cloud-netflix-core的源代码，里面有个ConfigurableEnvironmentConfiguration继承了apache的AbstractConfiguration，将spring Environment进行了封装，实例化后作为配置源加到archaius的组合配置中，并没有像DynamicURLConfiguration那样进行schedule。   </p><p>我们前面对archaius的源代码进行了详细的分析，可以对此进行改进，让spring更新env时，archaius配置项能感知到。首先增加一个配置源类，实现PolledConfigurationSource接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SpringEnvConfigurationSource implements PolledConfigurationSource &#123;</span><br><span class="line">    //spring的Environment</span><br><span class="line">    private ConfigurableEnvironment environment;</span><br><span class="line">    private PropertySourcesPropertyResolver resolver;</span><br><span class="line"></span><br><span class="line">    SpringEnvConfigurationSource(ConfigurableEnvironment environment) &#123;</span><br><span class="line">        this.environment = environment;</span><br><span class="line">        this.resolver = new PropertySourcesPropertyResolver(this.environment.getPropertySources());</span><br><span class="line">        this.resolver.setIgnoreUnresolvableNestedPlaceholders(true);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PollResult poll(boolean initial, Object checkPoint) throws Exception &#123;</span><br><span class="line">        log.debug(&quot;archaius config refresh.&quot;);</span><br><span class="line">        //poll是从spring env中拉取配置</span><br><span class="line">        return PollResult.createFull(getProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; getProperties() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; properties = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //spring env 里面也是多个source组合的</span><br><span class="line">        for (Map.Entry&lt;String, PropertySource&lt;?&gt;&gt; entry : getPropertySources().entrySet()) &#123;</span><br><span class="line">            PropertySource&lt;?&gt; source = entry.getValue();</span><br><span class="line">            if (source instanceof EnumerablePropertySource) &#123;</span><br><span class="line">                EnumerablePropertySource&lt;?&gt; enumerable = (EnumerablePropertySource&lt;?&gt;) source;</span><br><span class="line">                for (String name : enumerable.getPropertyNames()) &#123;</span><br><span class="line">                    if (!properties.containsKey(name)) &#123;</span><br><span class="line">                        properties.put(name, resolver.getProperty(name));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //PropertySource也可能是组合的，通过递归获取</span><br><span class="line">    private Map&lt;String, PropertySource&lt;?&gt;&gt; getPropertySources() &#123;</span><br><span class="line">        Map&lt;String, PropertySource&lt;?&gt;&gt; map = new LinkedHashMap&lt;String, PropertySource&lt;?&gt;&gt;();</span><br><span class="line">        MutablePropertySources sources = null;</span><br><span class="line">        if (environment != null) &#123;</span><br><span class="line">            sources = environment.getPropertySources();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sources = new StandardEnvironment().getPropertySources();</span><br><span class="line">        &#125;</span><br><span class="line">        for (PropertySource&lt;?&gt; source : sources) &#123;</span><br><span class="line">            extract(&quot;&quot;, map, source);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void extract(String root, Map&lt;String, PropertySource&lt;?&gt;&gt; map,</span><br><span class="line">                         PropertySource&lt;?&gt; source) &#123;</span><br><span class="line">        if (source instanceof CompositePropertySource) &#123;</span><br><span class="line">            for (PropertySource&lt;?&gt; nest : ((CompositePropertySource) source)</span><br><span class="line">                    .getPropertySources()) &#123;</span><br><span class="line">                extract(source.getName() + &quot;:&quot;, map, nest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(root + source.getName(), source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码是参考spring-cloud-netflix-core中的ConfigurableEnvironmentConfiguration实现的。<br>然后编写自动配置类代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(&quot;archaius&quot;)</span><br><span class="line">public class ArchaiusConfig implements EnvironmentAware, InitializingBean &#123;</span><br><span class="line">    private static final String CONFIG_NAME = &quot;springEnv&quot;;</span><br><span class="line">    @Setter</span><br><span class="line">    private int pollDelayMillis = 5000;</span><br><span class="line">    @Setter</span><br><span class="line">    private int poolInitialDelayMillis = 5000;</span><br><span class="line">    @Setter</span><br><span class="line">    private boolean pollIgnoreDeletesFromSource = false;</span><br><span class="line"></span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setEnvironment(Environment environment) &#123;</span><br><span class="line">        this.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        SpringEnvConfigurationSource springEnvConfigurationSource = new SpringEnvConfigurationSource((ConfigurableEnvironment) this.environment);</span><br><span class="line">        //新建一个PollingScheduler</span><br><span class="line">        FixedDelayPollingScheduler scheduler = new FixedDelayPollingScheduler(poolInitialDelayMillis, pollDelayMillis, pollIgnoreDeletesFromSource);</span><br><span class="line">        ConcurrentMapConfiguration configuration = new ConcurrentCompositeConfiguration();</span><br><span class="line">        //开始轮询，从SpringEnvConfigurationSource中拉取，archaius内部会比较配置的变化</span><br><span class="line">        scheduler.startPolling(springEnvConfigurationSource, configuration);</span><br><span class="line"></span><br><span class="line">        //初始化archaius，这段代码也是参考spring-cloud-netflix-core的</span><br><span class="line">        if (ConfigurationManager.isConfigurationInstalled()) &#123;</span><br><span class="line">            AbstractConfiguration installedConfiguration = ConfigurationManager.getConfigInstance();</span><br><span class="line">            if (installedConfiguration instanceof ConcurrentCompositeConfiguration) &#123;</span><br><span class="line">                ConcurrentCompositeConfiguration configInstance = (ConcurrentCompositeConfiguration) installedConfiguration;</span><br><span class="line">                if (configInstance.getConfiguration(CONFIG_NAME) == null)</span><br><span class="line">                    configInstance.addConfigurationAtFront(configuration, CONFIG_NAME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ConcurrentCompositeConfiguration concurrentCompositeConfiguration = new ConcurrentCompositeConfiguration();</span><br><span class="line">            concurrentCompositeConfiguration.addConfiguration(configuration, CONFIG_NAME);</span><br><span class="line">            ConfigurationManager.install(concurrentCompositeConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改启动类进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class TestApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigurableEnvironment env;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ArchaiusAutoConfiguration archaiusAutoConfiguration;</span><br><span class="line"></span><br><span class="line">    private static final DynamicStringProperty archaiusTest =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getStringProperty(&quot;archaius.test&quot;, &quot;test1&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">        Thread.sleep(50000 * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;env config: &quot; + env.getProperty(&quot;archaius.test&quot;));</span><br><span class="line">        System.out.println(&quot;archaius config: &quot; + archaiusTest.get());</span><br><span class="line">        //给env中增加一个配置源</span><br><span class="line">        MutablePropertySources sources = env.getPropertySources();</span><br><span class="line">        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();</span><br><span class="line">        config.put(&quot;archaius.test&quot;, &quot;map change&quot;);</span><br><span class="line">        //自定义的配置源加到最前面</span><br><span class="line">        sources.addFirst(new MapPropertySource(&quot;myMap&quot;, config));</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        Thread.sleep(2 * 1000);</span><br><span class="line">                        //打印archaius配置项</span><br><span class="line">                        System.out.println(&quot;archaius config: &quot; + archaiusTest.get());</span><br><span class="line">                        i++;</span><br><span class="line">                        //修改配置源</span><br><span class="line">                        config.put(&quot;archaius.test&quot;, &quot;map change &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">env config: archaius-test</span><br><span class="line">archaius config: archaius-test</span><br><span class="line">...</span><br><span class="line">archaius config: map change</span><br><span class="line">archaius config: map change</span><br><span class="line">archaius config: map change 2</span><br><span class="line">archaius config: map change 2</span><br><span class="line">archaius config: map change 2</span><br><span class="line">archaius config: map change 5</span><br><span class="line">archaius config: map change 5</span><br><span class="line">archaius config: map change 7</span><br><span class="line">archaius config: map change 7</span><br></pre></td></tr></table></figure></p><p>可以看到不是每次修改都会生效，轮询时间在ArchaiusConfig中进行的配置。代码地址：<a href="https://github.com/along101/spring-boot-test/tree/5ad5158732ea363aa4fb5b9b965c08977699a9c6/archaius-test" target="_blank" rel="noopener">https://github.com/along101/spring-boot-test/tree/5ad5158732ea363aa4fb5b9b965c08977699a9c6/archaius-test</a></p><p>就这么几十行代码就可以将archaius与spring boot结合起来了。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>archaius源码不多，重点在配置的初始化和动态变更这块。</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>初始化入口是<code>DynamicPropertyFactory.getInstance()</code>，来看看该方法源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static DynamicPropertyFactory getInstance() &#123;</span><br><span class="line">    if (config == null) &#123;</span><br><span class="line">        synchronized (ConfigurationManager.class) &#123;</span><br><span class="line">            if (config == null) &#123;</span><br><span class="line">                //先初始化AbstractConfiguration</span><br><span class="line">                AbstractConfiguration configFromManager = ConfigurationManager.getConfigInstance();</span><br><span class="line">                if (configFromManager != null) &#123;</span><br><span class="line">                    //初始化自己</span><br><span class="line">                    initWithConfigurationSource(configFromManager);</span><br><span class="line">                    initializedWithDefaultConfig = !ConfigurationManager.isConfigurationInstalled();</span><br><span class="line">                    logger.info(&quot;DynamicPropertyFactory is initialized with configuration sources: &quot; + configFromManager);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ConfigurationManager</code>的静态代码块中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">    ...省略部分代码</span><br><span class="line"></span><br><span class="line">    //设置部署上下文，会初始化environment、datacenter、applicationId、serverId、region等等，不配置的话，就为空</span><br><span class="line">    setDeploymentContext(new ConfigurationBasedDeploymentContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过一层层调用，调用到<code>createDefaultConfigInstance</code>来创建<code>AbstractConfiguration</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static AbstractConfiguration createDefaultConfigInstance() &#123;</span><br><span class="line">    //新建一个组合配置，配置列表中自带一个ConcurrentMapConfiguration，这个配置是containerConfiguration，容器自己的配置</span><br><span class="line">    ConcurrentCompositeConfiguration config = new ConcurrentCompositeConfiguration();  </span><br><span class="line">    try &#123;</span><br><span class="line">        //增加一个DynamicURLConfiguration，获取默认配置文件url和配置系统属性archaius.configurationSource.additionalUrls得到的url</span><br><span class="line">        //构造函数最后，开启线程定时从url里面更新配置</span><br><span class="line">        DynamicURLConfiguration defaultURLConfig = new DynamicURLConfiguration();</span><br><span class="line">        config.addConfiguration(defaultURLConfig, URL_CONFIG_NAME);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create default dynamic configuration&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!Boolean.getBoolean(DISABLE_DEFAULT_SYS_CONFIG)) &#123;</span><br><span class="line">        //增加SystemConfiguration</span><br><span class="line">        SystemConfiguration sysConfig = new SystemConfiguration();</span><br><span class="line">        config.addConfiguration(sysConfig, SYS_CONFIG_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!Boolean.getBoolean(DISABLE_DEFAULT_ENV_CONFIG)) &#123;</span><br><span class="line">        //增加环境配置</span><br><span class="line">        EnvironmentConfiguration envConfig = new EnvironmentConfiguration();</span><br><span class="line">        config.addConfiguration(envConfig, ENV_CONFIG_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    //增加app的组合配置</span><br><span class="line">    ConcurrentCompositeConfiguration appOverrideConfig = new ConcurrentCompositeConfiguration();</span><br><span class="line">    config.addConfiguration(appOverrideConfig, APPLICATION_PROPERTIES);</span><br><span class="line">    config.setContainerConfigurationIndex(config.getIndexOfConfiguration(appOverrideConfig));</span><br><span class="line">    return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化完后，得到一个组合配置，包含5个配置，顺序为：</p><ul><li>URL_CONFIG_NAME 通过url拉取的配置</li><li>SYS_CONFIG_NAME 系统属性配置,通过<code>System.getProperties()</code>获取的配置</li><li>ENV_CONFIG_NAME 环境配置,通过<code>System.getenv()</code>获取的配置</li><li>containerConfiguration 容器配置，<code>ConfigurationManager.getConfigInstance().setProperty(key,value)</code>设置的配置</li><li>APPLICATION_PROPERTIES 调用<code>configurationManager.loadAppOverrideProperties</code>设置的配置</li></ul><p><img src="/2018/05/08/20180508/config.png" alt=""></p><p>这样就生成了<code>AbstractConfiguration</code>，保存在<code>ConfigurationManager.instance</code>静态变量上。  </p><p>回到<code>DynamicPropertyFactory</code>代码里面，生成了<code>AbstractConfiguration configFromManager</code>之后，调用方法<code>initWithConfigurationSource</code>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static DynamicPropertyFactory initWithConfigurationSource(AbstractConfiguration config) &#123;</span><br><span class="line"></span><br><span class="line">        。。。</span><br><span class="line">        //包装config为DynamicPropertySupport</span><br><span class="line">        return initWithConfigurationSource(new ConfigurationBackedDynamicPropertySupportImpl(config));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面会设置<code>setDirect</code>，将<code>DynamicPropertySupport</code>注册到<code>DynamicProperty</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void setDirect(DynamicPropertySupport support) &#123;</span><br><span class="line">    synchronized (ConfigurationManager.class) &#123;</span><br><span class="line">        config = support;</span><br><span class="line">        DynamicProperty.registerWithDynamicPropertySupport(support);</span><br><span class="line">        initializedWithDefaultConfig = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicProperty</code>注册<code>DynamicPropertySupport</code>的过程是增加一个<code>DynamicPropertyListener</code>，更新所有的属性，也就是更新他的静态变量<code>ALL_PROPS</code>里面的配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static synchronized void initialize(DynamicPropertySupport config) &#123;</span><br><span class="line">    dynamicPropertySupportImpl = config;</span><br><span class="line">    config.addConfigurationListener(new DynamicPropertyListener());</span><br><span class="line">    updateAllProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里就初始化完了。根据以上源代码的分析，我们画出类图如下：</p><p><img src="/2018/05/08/20180508/init.png" alt=""></p><p>这里最重要的两个类是</p><ul><li><code>ConfigurationManager</code> 静态变量<code>AbstractConfiguration instance为</code>所有配置项信息</li><li><code>DynamicProperty</code> 静态变量<code>DynamicPropertySupport dynamicPropertySupportImpl</code>用于动态更新，静态变量<code>ConcurrentHashMap&lt;String, DynamicProperty&gt; ALL_PROPS</code>为被使用的动态属性</li></ul><h3 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h3><p>通过以下代码获取动态配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynamicLongProperty timeToWait =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getLongProperty(&quot;lock.waitTime&quot;, 1000);</span><br></pre></td></tr></table></figure></p><p>进入<code>getLongProperty</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public DynamicLongProperty getLongProperty(String propName, long defaultValue, final Runnable propertyChangeCallback) &#123;</span><br><span class="line">    //检查初始化</span><br><span class="line">    checkAndWarn(propName);</span><br><span class="line">    //新建一个动态配置</span><br><span class="line">    DynamicLongProperty property = new DynamicLongProperty(propName, defaultValue);</span><br><span class="line">    //增加回调</span><br><span class="line">    addCallback(propertyChangeCallback, property);</span><br><span class="line">    return property;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DynamicLongProperty</code>继承了<code>PropertyWrapper</code>，含有属性<code>DynamicProperty prop</code>，先初始化该属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.prop = DynamicProperty.getInstance(propName);</span><br></pre></td></tr></table></figure></p><p>再往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static DynamicProperty getInstance(String propName) &#123;</span><br><span class="line">    //dynamicPropertySupportImpl为空，先初始化DynamicPropertyFactory</span><br><span class="line">    if (dynamicPropertySupportImpl == null) &#123;</span><br><span class="line">        DynamicPropertyFactory.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    //从ALL_PROPS中获取prop，没有的话，新建，并放到ALL_PROPS中</span><br><span class="line">    //这里没有加同步设置，但是做了个小动作，没有并发问题</span><br><span class="line">    DynamicProperty prop = ALL_PROPS.get(propName);</span><br><span class="line">    if (prop == null) &#123;</span><br><span class="line">        prop = new DynamicProperty(propName);</span><br><span class="line">        //ALL_PROPS是ConcurrentHashMap，putIfAbsent是线程安全的，存在的话返回老的值</span><br><span class="line">        DynamicProperty oldProp = ALL_PROPS.putIfAbsent(propName, prop);</span><br><span class="line">        //oldProp不为null，返回oldProp，解决了并发的问题，副作用是多建了DynamicProperty对象</span><br><span class="line">        if (oldProp != null) &#123;</span><br><span class="line">            prop = oldProp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看<code>new DynamicProperty(propName)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    private DynamicProperty(String propName) &#123;</span><br><span class="line">        //设置属性名称</span><br><span class="line">        this.propName = propName;</span><br><span class="line">        updateValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//更新属性值</span><br><span class="line">private boolean updateValue() &#123;</span><br><span class="line">        String newValue;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (dynamicPropertySupportImpl != null) &#123;</span><br><span class="line">                //从dynamicPropertySupportImpl中获取配置项，这里是包装AbstractConfiguration的，也就是在ConfigurationManager中的instance</span><br><span class="line">                newValue = dynamicPropertySupportImpl.getString(propName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;Unable to update property: &quot; + propName, e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return updateValue(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">boolean updateValue(Object newValue) &#123;</span><br><span class="line">        String nv = (newValue == null) ? null : newValue.toString();</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            if ((nv == null &amp;&amp; stringValue == null)</span><br><span class="line">               || (nv != null &amp;&amp; nv.equals(stringValue))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //更新stringValue</span><br><span class="line">            stringValue = nv;</span><br><span class="line">            //刷新缓存</span><br><span class="line">            cachedStringValue.flush();</span><br><span class="line">            booleanValue.flush();</span><br><span class="line">            integerValue.flush();</span><br><span class="line">            floatValue.flush();</span><br><span class="line">            classValue.flush();</span><br><span class="line">            doubleValue.flush();</span><br><span class="line">            longValue.flush();</span><br><span class="line">            changedTime = System.currentTimeMillis();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里<code>DynamicLongProperty</code>对象就新建了，里面包含一个<code>DynamicProperty</code>，配置值的更新、回调都是由这个<code>DynamicProperty</code>完成的，他的属性有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//配置名称</span><br><span class="line">private String propName;</span><br><span class="line">//配置的值，原始string</span><br><span class="line">private String stringValue = null;</span><br><span class="line">//更新时间</span><br><span class="line">private long changedTime;</span><br><span class="line">//回到函数表</span><br><span class="line">private CopyOnWriteArraySet&lt;Runnable&gt; callbacks = new CopyOnWriteArraySet&lt;Runnable&gt;();</span><br><span class="line"></span><br><span class="line">//缓存的StringValue</span><br><span class="line">private CachedValue&lt;String&gt; cachedStringValue = new CachedValue&lt;String&gt;() &#123;</span><br><span class="line">    protected String parse(String rep) &#123;</span><br><span class="line">        return rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//缓存的integerValue</span><br><span class="line">private CachedValue&lt;Integer&gt; integerValue = new CachedValue&lt;Integer&gt;() &#123;</span><br><span class="line">    protected Integer parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Integer.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Long&gt; longValue = new CachedValue&lt;Long&gt;() &#123;</span><br><span class="line">    protected Long parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Long.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Float&gt; floatValue = new CachedValue&lt;Float&gt;() &#123;</span><br><span class="line">    protected Float parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Float.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Double&gt; doubleValue = new CachedValue&lt;Double&gt;() &#123;</span><br><span class="line">    protected Double parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Double.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Class&gt; classValue = new CachedValue&lt;Class&gt;() &#123;</span><br><span class="line">    protected Class parse(String rep) throws ClassNotFoundException &#123;</span><br><span class="line">        return Class.forName(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>CachedValue</code>是<code>DynamicLongProperty</code>的内部类，缓存了配置的实际值，通过解析<code>DynamicLongProperty</code>的stringValue值获取不同类型的配置值。下面我们来分析这一过程。<code>DynamicLongProperty.get()</code>获取动态配置项的值代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long get() &#123;</span><br><span class="line">    return prop.getLong(defaultValue).longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内置的prop属性即<code>DynamicProperty</code>获取的配置项，prop中通过属性longValue获取配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Long getLong(Long defaultValue) &#123;</span><br><span class="line">    return longValue.getValue(defaultValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面初始化prop时，会初始化属性<code>CachedValue&lt;Long&gt; longValue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private CachedValue&lt;Long&gt; longValue = new CachedValue&lt;Long&gt;() &#123;</span><br><span class="line">    protected Long parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Long.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>longValue是一个<code>CachedValue</code>类型，getValue方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public T getValue() throws IllegalArgumentException &#123;</span><br><span class="line">    // Not quite double-check locking -- since isCached is marked as volatile</span><br><span class="line">    if (!isCached) &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //如果配置值DynamicProperty.stringValue为null，则没有该配置项，返回null，否则解析stringValue返回</span><br><span class="line">                //这里的parse方法自然是调用longValue的parse方法返回Long值</span><br><span class="line">                value = (stringValue == null) ? null : parse(stringValue);</span><br><span class="line">                exception = null;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                value = null;</span><br><span class="line">                exception = new IllegalArgumentException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                isCached = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception != null) &#123;</span><br><span class="line">        throw exception;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，通过<code>DynamicLongProperty.getLongProperty</code>获取的配置值就能拿到了。其他的<code>DynamicIntProperty</code>、<code>DynamicStringProperty</code>等配置项的获取与此相同。</p><h3 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h3><p>archaius最有价值的特点是能动态更新配置项，这里动态更新的配置项是指前面我们分析初始化是的<code>DynamicURLConfiguration</code>，我们先看看<code>DynamicURLConfiguration</code>的是如何动态更新的，构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public DynamicURLConfiguration() &#123;</span><br><span class="line">    URLConfigurationSource source = new URLConfigurationSource();</span><br><span class="line">    if (source.getConfigUrls() != null &amp;&amp; source.getConfigUrls().size() &gt; 0) &#123;</span><br><span class="line">        startPolling(source, new FixedDelayPollingScheduler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的startPolling开始轮询url资源内容，然后更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void startPolling(PolledConfigurationSource source, AbstractPollingScheduler scheduler) &#123;</span><br><span class="line">    this.scheduler = scheduler;</span><br><span class="line">    this.source = source;</span><br><span class="line">    init(source, scheduler);</span><br><span class="line">    //然后schedule调度轮询</span><br><span class="line">    scheduler.startPolling(source, this);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void startPolling(final PolledConfigurationSource source, final Configuration config) &#123;</span><br><span class="line">    //先初始化</span><br><span class="line">    initialLoad(source, config);</span><br><span class="line">    Runnable r = getPollingRunnable(source, config);</span><br><span class="line">    schedule(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected synchronized void schedule(Runnable runnable) &#123;</span><br><span class="line">//线程池调度</span><br><span class="line">    executor = Executors.newScheduledThreadPool(1, new ThreadFactory() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread t = new Thread(r, &quot;pollingConfigurationSource&quot;);</span><br><span class="line">            t.setDaemon(true);</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executor.scheduleWithFixedDelay(runnable, initialDelayMillis, delayMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Runnable getPollingRunnable(final PolledConfigurationSource source, final Configuration config) &#123;</span><br><span class="line">    return new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.debug(&quot;Polling started&quot;);</span><br><span class="line">            PollResult result = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                //重点是这里，拉取配置结果</span><br><span class="line">                result = source.poll(false, getNextCheckPoint(checkPoint));</span><br><span class="line">                checkPoint = result.getCheckPoint();</span><br><span class="line">                fireEvent(EventType.POLL_SUCCESS, result, null);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error getting result from polling source&quot;, e);</span><br><span class="line">                fireEvent(EventType.POLL_FAILURE, null, e);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                //更新配置</span><br><span class="line">                populateProperties(result, config);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error occured applying properties&quot;, e);</span><br><span class="line">            &#125;                 </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是先初始化，从url中拉取配置，然后开启一个线程，间隔一段时间拉取，然后调用populateProperties方法更新配置。<br>source.poll代码比较简单，获取url资源，得到Properties，转换为map，封装在<code>PollResult</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public PollResult poll(boolean initial, Object checkPoint)</span><br><span class="line">        throws IOException &#123;    </span><br><span class="line">    if (configUrls == null || configUrls.length == 0) &#123;</span><br><span class="line">        return PollResult.createFull(null);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    for (URL url: configUrls) &#123;</span><br><span class="line">        InputStream fin = url.openStream();</span><br><span class="line">        Properties props = ConfigurationUtils.loadPropertiesFromInputStream(fin);</span><br><span class="line">        for (Entry&lt;Object, Object&gt; entry: props.entrySet()) &#123;</span><br><span class="line">            map.put((String) entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return PollResult.createFull(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>populateProperties更新配置的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected void populateProperties(final PollResult result, final Configuration config) &#123;</span><br><span class="line">        if (result == null || !result.hasChanges()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!result.isIncremental()) &#123;</span><br><span class="line">            //不是增量结果，即全量结果，默认使用的是全量结果</span><br><span class="line">            Map&lt;String, Object&gt; props = result.getComplete();</span><br><span class="line">            if (props == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //遍历每个配置项，进行更新</span><br><span class="line">            for (Entry&lt;String, Object&gt; entry: props.entrySet()) &#123;</span><br><span class="line">                propertyUpdater.addOrChangeProperty(entry.getKey(), entry.getValue(), config);</span><br><span class="line">            &#125;</span><br><span class="line">            //下面这段逻辑是删除配置项</span><br><span class="line">            HashSet&lt;String&gt; existingKeys = new HashSet&lt;String&gt;();</span><br><span class="line">            for (Iterator&lt;String&gt; i = config.getKeys(); i.hasNext();) &#123;</span><br><span class="line">                existingKeys.add(i.next());</span><br><span class="line">            &#125;</span><br><span class="line">            if (!ignoreDeletesFromSource) &#123;</span><br><span class="line">                for (String key: existingKeys) &#123;</span><br><span class="line">                    if (!props.containsKey(key)) &#123;</span><br><span class="line">                        propertyUpdater.deleteProperty(key, config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //增量结果，默认情况下是全量，一般不会走这里</span><br><span class="line">            。。。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>先遍历所有配置项进行更新，然后处理删除配置项。通过propertyUpdater.addOrChangeProperty更新配置型，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void addOrChangeProperty(final String name, final Object newValue, final Configuration config) &#123;</span><br><span class="line">        // We do not want to abort the operation due to failed validation on one property</span><br><span class="line">        try &#123;</span><br><span class="line">            //config中不包含配置项就增加</span><br><span class="line">            if (!config.containsKey(name)) &#123;</span><br><span class="line">                logger.debug(&quot;adding property key [&#123;&#125;], value [&#123;&#125;]&quot;, name, newValue);</span><br><span class="line"></span><br><span class="line">                config.addProperty(name, newValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //包含的话就比较</span><br><span class="line">                Object oldValue = config.getProperty(name);</span><br><span class="line"></span><br><span class="line">                if (newValue != null) &#123;</span><br><span class="line">                    Object newValueArray;</span><br><span class="line">                    //数组处理</span><br><span class="line">                    if (oldValue instanceof CopyOnWriteArrayList &amp;&amp; AbstractConfiguration.getDefaultListDelimiter() != &apos;\0&apos;)&#123;</span><br><span class="line">                        newValueArray =</span><br><span class="line">                                        new CopyOnWriteArrayList();</span><br><span class="line"></span><br><span class="line">                      Iterable&lt;String&gt; stringiterator = Splitter.on(AbstractConfiguration.getDefaultListDelimiter()).omitEmptyStrings().trimResults().split((String)newValue);</span><br><span class="line">                      for(String s :stringiterator)&#123;</span><br><span class="line">                            ((CopyOnWriteArrayList) newValueArray).add(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          newValueArray = newValue;</span><br><span class="line">                      &#125;</span><br><span class="line">                    //不相同修改配置</span><br><span class="line">                    if (!newValueArray.equals(oldValue)) &#123;</span><br><span class="line">                        logger.debug(&quot;updating property key [&#123;&#125;], value [&#123;&#125;]&quot;, name, newValue);</span><br><span class="line"></span><br><span class="line">                        config.setProperty(name, newValue);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; else if (oldValue != null) &#123;</span><br><span class="line">                    logger.debug(&quot;nulling out property key [&#123;&#125;]&quot;, name);</span><br><span class="line"></span><br><span class="line">                    config.setProperty(name, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ValidationException e) &#123;</span><br><span class="line">            logger.warn(&quot;Validation failed for property &quot; + name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更新配置项的过程是拿出老的配置值跟新的配置值进行比较，不相同才修改，还处理了下数组配置项。这里的config是<code>DynamicURLConfiguration</code>，setProperty方法中触发事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setProperty(String key, Object value) throws ValidationException</span><br><span class="line">&#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Value for property &quot; + key + &quot; is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fireEvent(EVENT_SET_PROPERTY, key, value, true);</span><br><span class="line">    setPropertyImpl(key, value);</span><br><span class="line">    fireEvent(EVENT_SET_PROPERTY, key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setPropertyImpl方法修改<code>DynamicURLConfiguration</code>内部保存的配置项，这里虽然改了<code>DynamicURLConfiguration</code>配置项值，但是真正用到的地方存在<code>DynamicProperty</code>中，触发fireEvent方法才会去修改<code>DynamicProperty</code>中的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void fireEvent(int type, String propName, Object propValue, boolean beforeUpdate) &#123;</span><br><span class="line">    if (listeners == null || listeners.size() == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationEvent event = createEvent(type, propName, propValue, beforeUpdate);</span><br><span class="line">    //通知每个监听器，这里listeners是一个CopyOnWriteArrayList类型，防止在遍历过程中更新数据产生问题</span><br><span class="line">    for (ConfigurationListener l: listeners)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            l.configurationChanged(event);</span><br><span class="line">        &#125; catch (ValidationException e) &#123;</span><br><span class="line">            if (beforeUpdate) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.error(&quot;Unexpected exception&quot;, e);                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.error(&quot;Error firing configuration event&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicURLConfiguration</code>添加到<code>ConcurrentCompositeConfiguration</code>中时，<code>ConcurrentCompositeConfiguration</code>会给每个Configuration增加一个<code>ConfigurationListener eventPropagater</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addConfigurationAtIndex(AbstractConfiguration config, String name, int index)</span><br><span class="line">    throws IndexOutOfBoundsException &#123;</span><br><span class="line">        if (!configList.contains(config)) &#123;</span><br><span class="line">            checkIndex(index);</span><br><span class="line">            configList.add(index, config);</span><br><span class="line">            if (name != null) &#123;</span><br><span class="line">                namedConfigurations.put(name, config);</span><br><span class="line">            &#125;</span><br><span class="line">            //将自己的属性eventPropagater添加到config的监听列表中</span><br><span class="line">            config.addConfigurationListener(eventPropagater);</span><br><span class="line">            fireEvent(EVENT_CONFIGURATION_SOURCE_CHANGED, null, null, false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.warn(config + &quot; is not added as it already exits&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicURLConfiguration</code>中就有一个<code>ConfigurationListener</code>的监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//ConcurrentCompositeConfiguration监听器属性初始化</span><br><span class="line">private ConfigurationListener eventPropagater = new ConfigurationListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configurationChanged(ConfigurationEvent event) &#123;</span><br><span class="line">        boolean beforeUpdate = event.isBeforeUpdate();</span><br><span class="line">        if (propagateEventToParent) &#123;</span><br><span class="line">            int type = event.getType();</span><br><span class="line">            String name = event.getPropertyName();</span><br><span class="line">            Object value = event.getPropertyValue();</span><br><span class="line">            Object finalValue;</span><br><span class="line">            switch(type) &#123;</span><br><span class="line">            case HierarchicalConfiguration.EVENT_ADD_NODES:</span><br><span class="line">            case EVENT_CLEAR:</span><br><span class="line">            case EVENT_CONFIGURATION_SOURCE_CHANGED:</span><br><span class="line">                fireEvent(type, name, value, beforeUpdate);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case EVENT_ADD_PROPERTY:</span><br><span class="line">            case EVENT_SET_PROPERTY:</span><br><span class="line">                //不管是beforeUpdate是true还是false，都会调用自己的fireEvent方法</span><br><span class="line">                if (beforeUpdate) &#123;</span><br><span class="line">                    // we want the validators to run even if the source is not</span><br><span class="line">                    // the winning configuration</span><br><span class="line">                    fireEvent(type, name, value, beforeUpdate);                                                </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    AbstractConfiguration sourceConfig = (AbstractConfiguration) event.getSource();</span><br><span class="line">                    AbstractConfiguration winningConf = (AbstractConfiguration) getSource(name);</span><br><span class="line">                    if (winningConf == null || getIndexOfConfiguration(sourceConfig) &lt;= getIndexOfConfiguration(winningConf)) &#123;</span><br><span class="line">                        fireEvent(type, name, value, beforeUpdate);                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case EVENT_CLEAR_PROPERTY:</span><br><span class="line">                finalValue = ConcurrentCompositeConfiguration.this.getProperty(name);</span><br><span class="line">                if (finalValue == null) &#123;</span><br><span class="line">                    fireEvent(type, name, value, beforeUpdate);                        </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fireEvent(EVENT_SET_PROPERTY, name, finalValue, beforeUpdate);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，最后都调用<code>ConcurrentCompositeConfiguration</code>的fireEvent方法，fireEvent是从父类继承过来的，作用是调用所有监听器，那么<code>ConcurrentCompositeConfiguration</code>的监听器有哪些呢？我们调试过程中发现有两个：</p><ul><li>ExpandedConfigurationListenerAdapter 配置监听适配器</li><li>ConfigurationBasedDeploymentContext.configListener 部署监听器，环境配置发生改变时，修改环境配置项</li></ul><p>重要的是这个<code>ExpandedConfigurationListenerAdapter</code>，作用是将arhaius定义的监听器适配到Apache定义的监听器上，一个典型的适配器模式。<code>ExpandedConfigurationListenerAdapter</code>含有一个<code>PropertyListener expandedListener</code>属性，实现类是<code>DynamicProperty</code>的内部类<code>DynamicPropertyListener</code>。初始化的地方在<code>DynamicPropertyFactory</code>方法setDirect中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void setDirect(DynamicPropertySupport support) &#123;</span><br><span class="line">    synchronized (ConfigurationManager.class) &#123;</span><br><span class="line">        config = support;</span><br><span class="line">        DynamicProperty.registerWithDynamicPropertySupport(support);</span><br><span class="line">        initializedWithDefaultConfig = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicProperty.registerWithDynamicPropertySupport</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void registerWithDynamicPropertySupport(DynamicPropertySupport config) &#123;</span><br><span class="line">    initialize(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static synchronized void initialize(DynamicPropertySupport config) &#123;</span><br><span class="line">    dynamicPropertySupportImpl = config;</span><br><span class="line">    //这里新建DynamicPropertyListener增加到config中</span><br><span class="line">    config.addConfigurationListener(new DynamicPropertyListener());</span><br><span class="line">    updateAllProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的config实现类是<code>ConfigurationBackedDynamicPropertySupportImpl</code>，同样是一个适配器模式，将apache的<code>DynamicPropertySupport</code>适配为archaius自己的<code>DynamicPropertySupport</code>，在<code>DynamicProperty</code>里面会用到。我们给出类图：</p><p><img src="/2018/05/08/20180508/listener.png" alt=""></p><p>根据前面的分析，fireEvent触发的事件最终会适配到<code>DynamicPropertyListener</code>的setProperty方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//事件触发中调用setProperty</span><br><span class="line">@Override</span><br><span class="line">public void setProperty(Object source, String name, Object value, boolean beforeUpdate) &#123;</span><br><span class="line">    if (!beforeUpdate) &#123;</span><br><span class="line">        updateProperty(name, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        validate(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//更新配置</span><br><span class="line">private static boolean updateProperty(String propName, Object value) &#123;</span><br><span class="line">    //从ALL_PROPS中找出动态配置，更新value</span><br><span class="line">    DynamicProperty prop = ALL_PROPS.get(propName);</span><br><span class="line">    if (prop != null &amp;&amp; prop.updateValue(value)) &#123;</span><br><span class="line">        //通知回调</span><br><span class="line">        prop.notifyCallbacks();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新stringValue值，然后刷新缓存</span><br><span class="line">boolean updateValue(Object newValue) &#123;</span><br><span class="line">    String nv = (newValue == null) ? null : newValue.toString();</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        if ((nv == null &amp;&amp; stringValue == null)</span><br><span class="line">           || (nv != null &amp;&amp; nv.equals(stringValue))) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        stringValue = nv;</span><br><span class="line">        cachedStringValue.flush();</span><br><span class="line">        booleanValue.flush();</span><br><span class="line">        integerValue.flush();</span><br><span class="line">        floatValue.flush();</span><br><span class="line">        classValue.flush();</span><br><span class="line">        doubleValue.flush();</span><br><span class="line">        longValue.flush();</span><br><span class="line">        changedTime = System.currentTimeMillis();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，才是真正的将<code>DynamicProperty</code>值更新了，<code>DynamicLongProperty</code>在更新之后获取数据时，会使用新值。  </p><p>接下来我们来看回调，<code>DynamicProperty</code>的notifyCallbacks方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void notifyCallbacks() &#123;</span><br><span class="line">    //遍历所有的callbacks，执行run</span><br><span class="line">    for (Runnable r : callbacks) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;Error in DynamicProperty callback&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里callbacks是<code>DynamicProperty</code>的属性，在给动态配置添加回调函数时，直接添加到<code>DynamicProperty.callbacks</code>属性中，来看<code>PropertyWrapper</code>类的addCallback犯法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addCallback(Runnable callback) &#123;</span><br><span class="line">        if (callback != null) &#123;</span><br><span class="line">            //这里的prop就是DynamicProperty</span><br><span class="line">            prop.addCallback(callback);</span><br><span class="line">            callbackList.add(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里，动态更新和回调就分析完了。  </p><p>有点复杂，我们再捋一遍：</p><ol><li><code>DynamicURLConfiguration</code>中的线程间隔一段时间从url中拉取配置</li><li>拉取配置后调用<code>AbstractPollingScheduler</code>类的populateProperties方法更新配置</li><li>populateProperties方法中调用属性<code>DynamicPropertyUpdater propertyUpdater</code>的addOrChangeProperty方法</li><li><code>DynamicPropertyUpdater</code>的方法addOrChangeProperty会进行新老配置型对比，调用<code>DynamicURLConfiguration</code>的setProperty方法修改变更项</li><li><code>DynamicURLConfiguration</code>的setProperty方法先修改本身存放的配置项，然后触发事件<code>fireEvent</code></li><li><code>DynamicURLConfiguration</code>中的监听器是<code>ConcurrentCompositeConfiguration</code>的属性<code>ConfigurationListener eventPropagater</code>,<code>ConcurrentCompositeConfiguration</code>每次增加配置源是会给每个源添加eventPropagater监听器</li><li><code>DynamicURLConfiguration</code>的fireEvent会通过eventPropagater触发<code>ConcurrentCompositeConfiguration</code>的fireEvent</li><li><code>ConcurrentCompositeConfiguration</code>的监听器包含一个<code>ExpandedConfigurationListenerAdapter</code>的适配器，包含一个<code>PropertyListener</code>的属性，将事件转到<code>PropertyListener</code>中</li><li><code>PropertyListener</code>的实现类是<code>DynamicProperty</code>的内部类<code>DynamicPropertyListener</code>，里面会调用<code>DynamicProperty</code>的静态方法<code>updateProperty</code></li><li><code>DynamicProperty</code>的<code>updateProperty</code>方法先从<code>ALL_PROPS</code>中获取配置<code>DynamicProperty</code>，更新配置项，然后通知所有的回调。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;archaius介绍&quot;&gt;&lt;a href=&quot;#archaius介绍&quot; class=&quot;headerlink&quot; title=&quot;archaius介绍&quot;&gt;&lt;/a&gt;archaius介绍&lt;/h2&gt;&lt;p&gt;archaius是Netflix公司开源项目之一，基于java的配置管理类库，主要用于多配置存储的动态获取。主要功能是对apache common configuration类库的扩展。在云平台开发中可以将其用作分布式配置管理依赖构件。同时，它有如下一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态获取属性&lt;/li&gt;
&lt;li&gt;高效和线程安全的配置操作&lt;/li&gt;
&lt;li&gt;配置改变时提供回调机制&lt;/li&gt;
&lt;li&gt;可以通过jmx操作配置&lt;/li&gt;
&lt;li&gt;复合配置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="微服务" scheme="http://techblog.ppdai.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="archaius" scheme="http://techblog.ppdai.com/tags/archaius/"/>
    
      <category term="动态配置" scheme="http://techblog.ppdai.com/tags/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>kong源码导读</title>
    <link href="http://techblog.ppdai.com/2018/04/16/20180416/"/>
    <id>http://techblog.ppdai.com/2018/04/16/20180416/</id>
    <published>2018-04-16T07:24:37.000Z</published>
    <updated>2018-04-16T11:05:07.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>&emsp;&emsp;kong是一个基于nginx和OpenResty模块构建的API网关服务。提供http请求路由，后端服务负载均衡以及通过丰富的插件提供认证鉴权、流量调控、日志监控等功能。该网关目前应用在全球著名的API管理站点<a href="https://market.mashape.com/explore?page=1" target="_blank" rel="noopener">mashape</a>上。<br>&emsp;&emsp;nginx是一个采用异步I/O，事件驱动的高性能Web服务器，也可以作为在企业内部提供基于http rpc的反向代理和负载均衡器。由于nginx的配置都是以静态文件的方式提供，而且nginx一般都是多台部署，导致nginx的运维管理变得比较复杂。许多运维的小伙伴都会写一些运维脚本，自动通过ssh命令远程连接到服务器去做一些配置更新的操作。<br>&emsp;&emsp;笔者所在公司也开发过一个基于nginx的软负载中心。用户可以在平台上为自己的服务配置反向代理以及负载均衡策略。用户所有的操作都会打包成一次对nginx配置的修改。修改指令会发送到每台nginx部署的一个agent上，最后由agent完成nginx配置文件的更新。<br>&emsp;&emsp;这些方法虽然可以达到自动化的管理nginx，但是本质上还是通过配置文件的方式去改变nginx的一些固定行为。在企业里面，特别是互联网公司常常需要定制一些功能。虽然可以为nginx开发一些模块，但是门槛较高，需要对nginx源码级的掌握。OpenResty为nginx引入的LuaJIT和lua-nginx-module，使我们可以在nginx的各个执行阶段编写一些lua脚本，极大地扩展了nginx的功能。OpenResty的作者已经用lua开发了许多工具库，使得我们可以在nginx中访问MySQL、Memcached、Redis。kong在此基础上实现了一个API网关服务。</p><a id="more"></a><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><h3 id="如何阅读源码"><a href="#如何阅读源码" class="headerlink" title="如何阅读源码"></a>如何阅读源码</h3><p>&emsp;&emsp;想必看这边文章的许多朋友之前对nginx都略有了解，但是可能是头一次接触lua语言，笔者当时也是头一次。这种情况笔者一般不会一上来就去阅读源码，而是先阅读下官方文档，把环境搭建起来之后试用下功能，然后看下日志。这样会对这个系统有个整体的感觉，之后就可以去翻翻源码了。笔者所使用的编辑器是IntelljIDEA，它可以自动识别出lua语言，然后提示你去下载支持该语言的插件，很是方便。笔者全程是在ubuntu环境下开发的，使用linux系统的好处是改完代码后执行下make命令，然后reload下nginx就可以看到效果。使用windows的童鞋建议装个linux的虚拟机。由于调试kong比较麻烦，所以笔者都是通过加日志的方式学习代码的。选取一些关键的流程打印一些数据会对源码的学习起到事半功倍的效果。有时候在troubleshooting的时候更加需要打印许多日志才能把问题定位到。<br>&emsp;&emsp;笔者使用的kong的版本为0.12.1</p><h3 id="如何使用该文档"><a href="#如何使用该文档" class="headerlink" title="如何使用该文档"></a>如何使用该文档</h3><p>&emsp;&emsp;本文档作为源码导读，在阅读本文档时手头最好有一份kong的源码以便随时进入源码深入阅读。读者不必从头到尾进行通读，可以根据目录选择自己感兴趣的章节进行阅读。</p><h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><p>|– kong<br>&emsp;&emsp;|– api [admin管理接口的代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– cluster_events [集群事件的数据访问层代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– cmd [kong命令行的代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– core [请求处理、路由、负载均衡等核心代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– dao [数据库访问层代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– plugins [插件的代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– templates [nginx配置文件模板]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– tools [工具类代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– vendor [这里提供了用于lua面向对象编程的基类]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– cache.lua [缓存实现类，封装了mlcache]<br>&emsp;&emsp;|– cluster_events.lua [集群事件同步代码]<br>&emsp;&emsp;|– conf_loader.lua [配置加载]<br>&emsp;&emsp;|– constants.lua [常量定义]<br>&emsp;&emsp;|– init.lua [kong的入口，可以从这里开始阅读代码]<br>&emsp;&emsp;|– meta.lua [定义版本号之类]<br>&emsp;&emsp;|– mlcache.lua [封装了lua-resty-mlcache]<br>&emsp;&emsp;|– singletons.lua [单例模式，存放公共对象]  </p><h3 id="执行入口"><a href="#执行入口" class="headerlink" title="执行入口"></a>执行入口</h3><p>&emsp;&emsp;以下是kong的nginx配置文件，笔者把一些和本章主题无关的先去掉了。  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block &#123;</span><br><span class="line">    kong = <span class="built_in">require</span> <span class="string">'kong'</span></span><br><span class="line">    kong.init()</span><br><span class="line">&#125;</span><br><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    kong.init_worker()</span><br><span class="line">&#125;</span><br><span class="line">upstream kong_upstream &#123;</span><br><span class="line">    server <span class="number">0.0</span><span class="number">.0</span><span class="number">.1</span>;</span><br><span class="line">    balancer_by_lua_block &#123;</span><br><span class="line">        kong.balancer()</span><br><span class="line">    &#125;</span><br><span class="line">    keepalive <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    server_name kong;</span><br><span class="line">    listen <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span>;</span><br><span class="line">    location / &#123;     </span><br><span class="line">        rewrite_by_lua_block &#123;</span><br><span class="line">            kong.rewrite()</span><br><span class="line">        &#125;</span><br><span class="line">        access_by_lua_block &#123;</span><br><span class="line">            kong.access()</span><br><span class="line">        &#125;</span><br><span class="line">        header_filter_by_lua_block &#123;</span><br><span class="line">            kong.header_filter()</span><br><span class="line">        &#125;</span><br><span class="line">        body_filter_by_lua_block &#123;</span><br><span class="line">            kong.body_filter()</span><br><span class="line">        &#125;</span><br><span class="line">        log_by_lua_block &#123;</span><br><span class="line">            kong.<span class="built_in">log</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /kong_error_handler &#123;</span><br><span class="line">        internal;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            kong.handle_error()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到kong的代码执行入口在init_by_lua_block块中，该块中的代码会在nginx的master加载配置的时候被执行。通过require ‘kong’得到的实例是一个全局对象，在Lua虚拟机里面执行的代码都可以访问到。<br>该实例通过master的fork进程方法共享给worker，如果worker修改该实例会触发操作系统进程的copy-on-write，worker进程就会拥有该实例的一个副本。<br>&emsp;&emsp;后缀是by_lua_block的都代表nginx处理请求的一个执行阶段，每个阶段都会执行相应的kong代码。nginx执行阶段流程如下如所示:  </p><p><img src="/2018/04/16/20180416/openresty_phases.png" alt=""></p><ul><li>init_by_lua*<br>&emsp;&emsp;发生在master进程启动阶段。这里会对数据访问层进行初始化，加载插件的代码，构造路由规则表。  </li><li>init_worker_by_lua*<br>&emsp;&emsp;发生在worker进程启动阶段。这里会开启数据同步机制，执行每个插件的init_worker方法。  </li><li>set_by_lua*<br>&emsp;&emsp;处理请求第一个执行阶段。这里可以做一些流程分支处理判断变量初始化。kong没有使用该阶段。</li><li>rewrite_by_lua*<br>&emsp;&emsp;这里可以对请求做一些修改。kong在这里会把处理代理给插件的rewrite方法。  </li><li>access_by_lua*<br>&emsp;&emsp;kong在这里对请求进行路由匹配，找到后端的upstream服务的节点。  </li><li>balancer_by_lua*<br>&emsp;&emsp;kong在这里会把上一阶段找到的服务节点设置给nginx的load balancer。如果设置了重试次数，此阶段可能会被执行多次。  </li><li>header_filter_by_lua*<br>&emsp;&emsp;这里可以对响应头做一些处理。kong在这里会把处理代理给插件的header_filter方法。  </li><li>body_filter_by_lua*<br>&emsp;&emsp;这里可以对响应体做一些处理。kong在这里会把处理代理给插件的body_filter方法。  </li><li>log_by_lua*<br>&emsp;&emsp;kong在这里会通过插件异步记录日志和一些metrics数据。  </li></ul><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>&emsp;&emsp;kong有三大核心模块：请求路由(Router)、负载均衡(Balancer)和集群数据同步。这3个模块加上插件就组成了kong的所有功能。<br>&emsp;&emsp;路由和负载均衡模块完全接管了nginx本身的策略，也是作为一个网关的核心功能。集群数据同步则弥补了nginx集群管理的缺点，可以使得路由规则和负载均衡策略的修改可以动态进行，省去了修改配置文件和重启的流程。       </p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;路由是Kong的核心功能之一。Kong会代理HTTP请求，根据HTTP主机头、请求URI和请求方式(GET/POST等)匹配路由规则，找到实际处理请求的后端服务。</p><p>&emsp;&emsp;Kong的路由规则由HTTP主机头、请求URI和请求方式组成。规则匹配发生在Nginx的Rewrite/Access阶段中，access_by_lua_block指令块里面的kong.access()方法的前置handler中。见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L85" target="_blank" rel="noopener">kong-nginx.conf:85</a>  </p><p>&emsp;&emsp;路由规则的原始数据存储在数据库apis表中。HTTP主机头由表字段hosts描述、请求URI由表字段uris描述、请求方式由表字段methods描述。在MySQL中，这3个字段的数据存储格式都是JSON序列化之后字符串数组。apis的表结构描述如下： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`apis`</span> (</span><br><span class="line">  <span class="comment">-- guid</span></span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 名称</span></span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- upstream标识</span></span><br><span class="line">  <span class="string">`upstream_url`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 是否保留主机头</span></span><br><span class="line">  <span class="string">`preserve_host`</span> tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 主机头匹配</span></span><br><span class="line">  <span class="string">`hosts`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- uri匹配</span></span><br><span class="line">  <span class="string">`uris`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 请求方法匹配</span></span><br><span class="line">  <span class="string">`methods`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 是否只接受https的请求</span></span><br><span class="line">  <span class="string">`https_only`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="comment">-- 如果接受https的请求并且客户端IP不在授信IP中，是否终止请求</span></span><br><span class="line">  <span class="string">`http_if_terminated`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="comment">-- 由于链路问题(connection timeouts, connection resets等或者5xx错误)导致请求转发失败重试次数</span></span><br><span class="line">  <span class="string">`retries`</span> <span class="built_in">smallint</span>(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="string">'5'</span>,</span><br><span class="line">  <span class="comment">-- 如果是uri前缀匹配，是否剥离掉uri前缀</span></span><br><span class="line">  <span class="string">`strip_uri`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span>,</span><br><span class="line">  <span class="comment">-- 一些超时时间</span></span><br><span class="line">  <span class="string">`upstream_connect_timeout`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'60000'</span>,</span><br><span class="line">  <span class="string">`upstream_send_timeout`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'60000'</span>,</span><br><span class="line">  <span class="string">`upstream_read_timeout`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'60000'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`name`</span> (<span class="string">`name`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`apis_name_idx`</span> (<span class="string">`name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;路由规则的创建在Nginx的初始化阶段，init_by_lua_block指令块中的kong.init()方法里。见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L26" target="_blank" rel="noopener">kong-nginx.conf:26</a>  </p><p>&emsp;&emsp;在kong.init()的末尾调用core.build_router(dao, “init”)方法构造路由表。见<a href="https://github.com/Kong/kong/blob/master/kong/init.lua#L174" target="_blank" rel="noopener">init.lua:174</a>。  </p><p>&emsp;&emsp;build_router方法的第一个参数是一个数据库操作对象，会使用它查询出数据库apis表中的数据。第二个参数是一个路由表在缓存中的版本号。如果apis表的数据发生变化，会触发缓存的invalidate操作，生成出一个新的version。此时在kong.access()方法中会再次调用build_router对路由表进行重建。见<a href="https://github.com/Kong/kong/blob/master/kong/core/handler.lua#L336" target="_blank" rel="noopener">handler.lua:336</a>。  </p><p>&emsp;&emsp;build_router会对从apis表中查询出来的数据按创建时间created_at从小到大进行排序。见<a href="https://github.com/Kong/kong/blob/master/kong/core/handler.lua#L54" target="_blank" rel="noopener">handler.lua:54</a>。这样如果2条规则相同的话较早的规则会优先匹配。接着会构造一个Router对象，它会负责路由表的创建、路由规则的匹配操作。  </p><h3 id="生成规则"><a href="#生成规则" class="headerlink" title="生成规则"></a>生成规则</h3><p>&emsp;&emsp;Router对象的第一个核心功能就是把数据库中的apis数据转化为适合进行匹配的规则。规则类型有3种：HOST、URI和METHOD，见<a href="https://github.com/Kong/kong/blob/master/kong/core/router.lua#L56" target="_blank" rel="noopener">router.lua:56</a>。这3种类型分别由位标识0x01、0x02和0x04表示。3种类型组成7种匹配方式：  </p><ul><li>HOST and URI and METHOD，位标识为(0x01 | 0x02 | 0x04) == 0x07</li><li>HOST and URI，位标识为(0x01 | 0x02) == 0x03</li><li>HOST and METHOD，位标识为(0x01 | 0x04) == 0x05</li><li>METHOD and URI，位标识为(0x04 | 0x02) == 0x06</li><li>HOST，位标识为0x01</li><li>URI，位标识为0x02</li><li>METHOD， 位标识为0x04  </li></ul><p>&emsp;&emsp;创建规则前会先把数据库里存储的apis对象格式化成api_t对象，api_t格式如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">api_t      = &#123;</span><br><span class="line">    <span class="comment">-- 数据库里面的apis对象</span></span><br><span class="line">    api            = api,</span><br><span class="line">    <span class="comment">-- 是否对URI按前缀进行剥离</span></span><br><span class="line">    strip_uri      = api.strip_uri,</span><br><span class="line">    <span class="comment">-- 请求转发的时候是否保留原始主机头</span></span><br><span class="line">    preserve_host  = api.preserve_host,</span><br><span class="line">    <span class="comment">-- 7种匹配方式的位标识</span></span><br><span class="line">    match_rules    = <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">-- 主机头匹配规则，当作数组使用</span></span><br><span class="line">    hosts          = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- uri匹配规则，当作数组使用</span></span><br><span class="line">    uris           = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- method匹配规则，当作词典使用</span></span><br><span class="line">    methods        = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- upstream信息</span></span><br><span class="line">    upstream_url_t = &#123;&#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果主机头匹配里面包含通配符，如：*.example.com，则把通配表达式转成正则表达式：.+\\.example\\.com$，然后hosts字段里面存储的对象格式为： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    wildcard = <span class="literal">true</span>,</span><br><span class="line">    value    = <span class="string">'*.example.com'</span>,</span><br><span class="line">    regex    = <span class="string">'.+\\.example\\.com$'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果主机头匹配里面是普通的字符串，如：abc.example.com，那么hosts字段里面存储的对象格式为：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value    = abc.example.com,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用正则表达式：^[a-zA-Z0-9.-_~/%]*$ 判断uri匹配是否是一个普通的uri前缀。如果是，如：/prefix/some，则uris字段里面存储的对象格式为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    is_prefix = <span class="literal">true</span>,</span><br><span class="line">    value    = <span class="string">'/prefix/some'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;如果uri匹配是包含正则字符串，如：/users/\d+/profile，则uris字段里面存储的对象格式为：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    is_regex     = <span class="literal">true</span>,</span><br><span class="line">    value        = <span class="string">'/users/\d+/profile'</span>,</span><br><span class="line">    regex        = <span class="string">'/users/\d+/profile'</span>,</span><br><span class="line">    has_captures = <span class="literal">false</span>,</span><br><span class="line">    strip_regex  = <span class="string">'/users/\d+/profile/?(?&lt;stripped_uri&gt;.*)'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>&emsp;&emsp;如果method匹配是get方式，则会把get转成大写，如：GET，以此作为key放入methods词典中。</p><p>&emsp;&emsp;使用一个词典数据结构categories对api_t对象以7种匹配方式进行归类。词典的key为7种匹配方式的位标识：0x01、0x02、0x03、0x04、0x05、0x06、0x07，value里面会按host、uri和method对规则进行分组。value定义如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">-- 按host分组的规则，词典类型</span></span><br><span class="line">    apis_by_hosts   = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- 按uri分组的规则，词典类型</span></span><br><span class="line">    apis_by_uris    = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- 按method分组的规则，词典类型</span></span><br><span class="line">    apis_by_methods = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- 该匹配模式下所有规则，数组类型</span></span><br><span class="line">    all             = &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;如果一个匹配规则是hosts=[abc.com]、uris=[/path]、method=[GET]，那么categories会包含此规则的api_t对象。如下所示：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">7</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        abc.com = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /<span class="built_in">path</span> = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_methods = &#123;</span><br><span class="line">        GET = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t对象],  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;如果另一个匹配规则是hosts=[abc.com]、uris=[/version]，那么categories会包含此规则的api_t对象2。如下所示：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">3</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        abc.com = [api_t对象<span class="number">2</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /version = [api_t对象<span class="number">2</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t对象<span class="number">2</span>],  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">7</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        abc.com = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /<span class="built_in">path</span> = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_methods = &#123;</span><br><span class="line">        GET = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t对象],  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;另外使用一个词典数据结构plain_indexes和3个数组结构uris_prefixes、uris_regexes、和wildcard_hosts决定优先使用哪种匹配模式。它们的创建方式见<a href="https://github.com/Kong/kong/blob/master/kong/core/router.lua#L252" target="_blank" rel="noopener">router.lua:252</a>。首先会使用plain_indexes匹配主机头、uri和请求方法，因为它的构造是一个词典结构，可直接根据主机头、uri和请求方法进行查询，效率比较高。plain_indexes的内容如下： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hosts = &#123;</span><br><span class="line">      abc.com   = <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    uris = &#123;</span><br><span class="line">      /foo = <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods = &#123;</span><br><span class="line">     GET = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>&emsp;&emsp;如果在plain_indexes里面没有查询到的话，则使用uris_prefixes、uris_regexes、和wildcard_hosts里面的规则一个一个进行匹配，直到匹配成功为止。</p><h3 id="匹配流程"><a href="#匹配流程" class="headerlink" title="匹配流程"></a>匹配流程</h3><p>&emsp;&emsp;规则的匹配在kong.access方法里面，调用router.exec方法进行匹配。见<a href="https://github.com/Kong/kong/blob/master/kong/core/handler.lua#L354" target="_blank" rel="noopener">handler.lua:354</a>。  </p><p>&emsp;&emsp;router.exec方法从http请求里面获取主机头信息、HTTP请求方法和请求URI。然后调用find_api方法进行实际地匹配。见<a href="https://github.com/Kong/kong/blob/master/kong/core/router.lua#L594" target="_blank" rel="noopener">router.lua:594</a>。   </p><p>&emsp;&emsp;find_api首先从缓存里面查询匹配结果。如果缓存里面没有数据，则是第一次匹配。先把请求中的主机头放入ctx.req_host，请求uri放入ctx.req_uri，请求方法放入ctx.req_method。然后使用plain_indexes、uris_prefixes、uris_regexes、和wildcard_hosts选择匹配模式。这里如果是根据uri前缀、uri正则表达式或主机头通配符匹配到的话，则会把uri前缀或uri正则表达式放入ctx.hits.uri中，把主机头通配符放入ctx.hits.host中。后续就使用ctx去和规则进行匹配。匹配模式按照CATEGORIES定义的顺序进行降级匹配。如果匹配模式是0x07，则使用0x07里面的规则去匹配。如果匹配失败，则使用0x03的规则进行匹配。如果还是失败，则继续按0x05 -&gt; 0x06 -&gt; 0x01 -&gt; 0x02 -&gt; 0x04的降级顺序进行匹配，直到成功为止。  </p><p>&emsp;&emsp;确定匹配模式之后，先使用reduce方法对候选的规则进行筛选。前面说到每一种匹配模式包含的规则会按host、uri和method进行分组。reduce方法就是选取数量最少的那个分组。如果那个分组下的规则匹配失败，则使用all下面的规则进行匹配。  </p><p>&emsp;&emsp;现在举例说明。假设现在根据如下json创建了一个apis对象。  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"my-api"</span>,</span><br><span class="line">    <span class="attr">"upstream_url"</span>: <span class="string">"http://my-api.com"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>, <span class="string">"service.com"</span>],</span><br><span class="line">    <span class="attr">"uris"</span>: [<span class="string">"/foo"</span>, <span class="string">"/bar"</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"GET"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;对应的api_t内容是：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">api_t      = &#123;</span><br><span class="line">    api            = 数据库中的api对象,</span><br><span class="line">    strip_uri      = <span class="literal">false</span>,</span><br><span class="line">    preserve_host  = <span class="literal">false</span>,</span><br><span class="line">    match_rules    = <span class="number">0x07</span>,</span><br><span class="line">    hosts          = [</span><br><span class="line">                      &#123;</span><br><span class="line">                                value    = example.com,</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                                value    = service.com,</span><br><span class="line">                      &#125;</span><br><span class="line">    ],</span><br><span class="line">    uris           = [</span><br><span class="line">                      &#123;</span><br><span class="line">                                is_prefix = <span class="literal">true</span>,</span><br><span class="line">                                value    = <span class="string">'/foo'</span>,  </span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                                is_prefix = <span class="literal">true</span>,</span><br><span class="line">                                value    = <span class="string">'/bar'</span>,  </span><br><span class="line">                      &#125;</span><br><span class="line">    ],</span><br><span class="line">    methods        = &#123;GET = <span class="literal">true</span>&#125;,</span><br><span class="line">    upstream_url_t = &#123;</span><br><span class="line">                         scheme             = http,</span><br><span class="line">                         host               = my-api.com,</span><br><span class="line">                         port               = <span class="number">80</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  <p>&emsp;&emsp;categories内容如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">7</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        example.com = [api_t],</span><br><span class="line">        service.com = [api_t]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /foo = [api_t],</span><br><span class="line">        /bar = [api_t],</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_methods = &#123;</span><br><span class="line">        GET = [api_t]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t],  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;plain_indexes的内容如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hosts = &#123;</span><br><span class="line">      example.com   = <span class="literal">true</span>,</span><br><span class="line">      service.com   = <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    uris = &#123;</span><br><span class="line">      /foo = <span class="literal">true</span>,</span><br><span class="line">      /bar = <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods = &#123;</span><br><span class="line">     GET = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;uris_prefixes的内容如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      is_prefix = <span class="literal">true</span>,</span><br><span class="line">      value    = <span class="string">'/foo'</span>,  </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      is_prefix = <span class="literal">true</span>,</span><br><span class="line">      value    = <span class="string">'/bar'</span>,  </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;由于host匹配没有通配符以及uri匹配没有正则表达式，所以uris_regexes和wildcard_hosts为空。  </p><p>&emsp;&emsp;假设现在有如下请求：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/<span class="number">1.1</span></span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;此请求的主机头是example.com，请求uri是/foo，请求方法是GET。首先使用plain_indexes确定匹配模式为0x07，因为plain_indexes.hosts包含example.com，位标识是0x01。plain_indexes.uris包含/foo，位标识是0x02。plain_indexes.methods包含GET，位标识是0x04。把0x01，0x02和0x04通过位或运算得到0x07。  </p><p>&emsp;&emsp;根据0x07从categories里选择key为7的规则。reduce方法等价于:<br><code>min(#categories[7].apis_by_hosts[example.com], #categories[7].apis_by_uris[/foo], #categories[7].apis_by_methods[GET])</code><br>&emsp;&emsp;#号是取数组的长度。此处这3个数组的长度都是1，所以优先选择apis_by_hosts中的api_t规则进行匹配。  api_t里面的hosts、uris和methods匹配上了这个请求，此次匹配成功。  </p><h2 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h2><h3 id="概览-2"><a href="#概览-2" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;Balancer对请求做负载均衡，使请求分散地转发到后端服务。从而可以优化资源利用率、提升吞吐量、减少延时以及提高容错等。Kong使用了DNS-Balancer和Ring-Balancer两种均衡模式。DNS-Balancer适合对外部的第三方服务进行负载均衡。候选服务器列表添加在A记录或SRV记录中。A记录中只包含IP地址，而且没有权重信息，适合简单的round-robin。SRV记录中包含IP地址和端口，并含有权重信息，可以按权重调拨流量以及IP地址复用。Ring-Balancer适合对内部服务进行负载运行。因为这种模式的控制性强，可以灵活地支持机器上下线操作、带权重的负载均衡以及可以进行蓝绿部署和金丝雀发布。本章着重分析Ring模式。  </p><h3 id="Ring-Balancer"><a href="#Ring-Balancer" class="headerlink" title="Ring-Balancer"></a>Ring-Balancer</h3><p>&emsp;&emsp;在Kong里面，Ring-Balancer通过upstream和target对象描述。upstream对象用于调节负载均衡的行为，如权重分配、健康检查以及是否通过一致性hash绑定请求到对应的机器上。target存储进行负载均衡的机器列表。  </p><p>&emsp;&emsp;upstream对象数据库表结构描述如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> upstreams (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 槽位大小，用于调节权重</span></span><br><span class="line">  slots <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- json格式存储的健康检查配置</span></span><br><span class="line">  healthchecks <span class="built_in">varchar</span>(<span class="number">10000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 首选hash输入值：none,consumer,ip,header</span></span><br><span class="line">  hash_on <span class="built_in">varchar</span>(<span class="number">31</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 此选hash输入值</span></span><br><span class="line">  hash_fallback <span class="built_in">varchar</span>(<span class="number">31</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 根据http header进行hash时，首选的header</span></span><br><span class="line">  hash_on_header <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 此选的header</span></span><br><span class="line">  hash_fallback_header <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  created_at <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="keyword">name</span> (<span class="keyword">name</span>),</span><br><span class="line">  <span class="keyword">KEY</span> upstreams_name_idx (<span class="keyword">name</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;target对象数据库表结构描述如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> targets (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- ip:port</span></span><br><span class="line">  target <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 权重值</span></span><br><span class="line">  weight <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 所属upstream</span></span><br><span class="line">  upstream_id <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  created_at <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> tragets_upstreamid_fk (upstream_id),</span><br><span class="line">  <span class="keyword">KEY</span> targets_target_idx (target),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> tragets_upstreamid_fk FOREIGN <span class="keyword">KEY</span> (upstream_id) <span class="keyword">REFERENCES</span> upstreams (<span class="keyword">id</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure> <h4 id="构造balancer"><a href="#构造balancer" class="headerlink" title="构造balancer"></a>构造balancer</h4><p>&emsp;&emsp;Ring-Balancer的初始化发生在nginx工作进程的初始化阶段中，init_worker_by_lua_block指令块的kong.init_worker()方法里，见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L30" target="_blank" rel="noopener">nginx-kong.conf:30</a>。init_worker里面调用了balancer.init()方法做了实际的初始化工作。  </p><p>&emsp;&emsp;balancer.init首先使用get_all_upstreams方法从数据库upstreams表加载所有数据到缓存中。调用create_balancer方法对每个查询出来的upstream对象，创建一个负载均衡器ring_balancer。均衡器的实现在resty.dns.balancer模块中，这个模块在Kong的lua-resty-dns-client项目里，代码见<a href="https://github.com/Kong/lua-resty-dns-client" target="_blank" rel="noopener">github</a>，文档见<a href="https://kong.github.io/lua-resty-dns-client/modules/resty.dns.balancer.html" target="_blank" rel="noopener">resty.dns.balancer</a>。  </p><p>&emsp;&emsp;均衡器初始化使用了3个参数：wheelSize,order和dns，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L295" target="_blank" rel="noopener">balancer.lua:295</a>。在0.12.1版本中，实际使用的就wheelSize这一个参数。如果wheelSize越大，目标机器的分布就越离散。这样在选择的时候既可以保证权重，连续选到相同的机器的概率也比较小。当然wheelSize越大，占用的内存就越多，重建的开销比较大。可以根据后端机器的数量选择的一个值，它的默认值是1000。  </p><h4 id="加载target"><a href="#加载target" class="headerlink" title="加载target"></a>加载target</h4><p>&emsp;&emsp;fetch_target_history方法会从key为balancer:targets:${upstreamId}的缓存中选择upstream下面的target，如果缓存中没有就调用load_targets_into_memory方法从数据库中查询出来再放入缓存。<br>&emsp;&emsp;Kong的api没有对target按ip和端口进行修改的操作。(这是因为如果只是做添加操作的话，可以不重建balancer，减少开销，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L364" target="_blank" rel="noopener">balancer.lua:364</a>。但是在check_target_history方法中有一个bug，导致即使只是添加target，还是会重建balancer，bug见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L357" target="_blank" rel="noopener">balancer.lua:357</a>，这里把old_history和new_history写反了。)<br>&emsp;&emsp;由于只做添加，数据库表targets中可能会出现多条target相同的数据(ip和port相同)，但是权重是不同的数据。如果出现这种情况该决定使用哪个target记录呢?fetch_target_history方法会对查询出来的target记录按创建时间进行从老到新的排序，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L116" target="_blank" rel="noopener">balancer.lua:116</a>。之后apply_history方法会按这个顺序把target添加到均衡器ring_balancer中，如果ip和端口相同，ring_balancer中后添加的记录会覆盖之前的，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L314" target="_blank" rel="noopener">balancer.lua:314</a>。 </p><p>&emsp;&emsp;无论是Ring-Balancer或DNS-Balancer，都是使用resty.dns.balancer这个负载均衡器做的负载均衡。这是因为在调用resty.dns.balancer的addHost方式时。如果hostname传的是域名的话，会做dns解析，把解析出来的节点添加进去。但如果hostname是ip地址的话，直接把添加参数所表示的节点。文档见<a href="https://kong.github.io/lua-resty-dns-client/modules/resty.dns.balancer.html#addHost" target="_blank" rel="noopener">addHost</a></p><h4 id="target健康检查"><a href="#target健康检查" class="headerlink" title="target健康检查"></a>target健康检查</h4><p>&emsp;&emsp;create_healthchecker方法为每个负载均衡器ring_balancer添加健康检查。<br>健康检查的实现在resty.healthcheck模块中，这个模块在Kong的lua-resty-healthcheck项目里，代码见<a href="https://github.com/Kong/lua-resty-healthcheck" target="_blank" rel="noopener">github</a>，文档见<a href="https://kong.github.io/lua-resty-healthcheck/modules/resty.healthcheck.html" target="_blank" rel="noopener">resty.healthcheck</a>。<br>&emsp;&emsp;create_healthchecker使用如下代码构造健康检查器：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> healthchecker, err = healthcheck.new(&#123;</span><br><span class="line">   name = upstream.name,</span><br><span class="line">   shm_name = <span class="string">"kong_healthchecks"</span>,</span><br><span class="line">   checks = upstream.healthchecks,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;shm_name传递的是lua-resty-healthcheck需要的nginx中的共享内存名，用于存储当前哪些节点的失败或成功次数。定义见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L21" target="_blank" rel="noopener">nginx-conf:21</a>。</p><p>&emsp;&emsp;checks传递的是健康检查的json配置。健康检查有主动检查和被动检查2种。  </p><p>&emsp;&emsp;主动检查需要设置检查url、超时时间、检查间隔、失败判断码、失败判断次数、成功判断码、成功判断次数、超时判断次数等。<br>&emsp;&emsp;kong默认的主动检查配置如下(这个配置不会启用主动检查，因为tcp_failures、timeouts、http_failures、interval和successes都被设成了0)：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">"active":&#123;</span><br><span class="line">    "unhealthy":&#123;</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            429,</span><br><span class="line">            404,</span><br><span class="line">            500,</span><br><span class="line">            501,</span><br><span class="line">            502,</span><br><span class="line">            503,</span><br><span class="line">            504,</span><br><span class="line">            <span class="number">505</span></span><br><span class="line">        ],</span><br><span class="line">        "tcp_failures":0,</span><br><span class="line">        "timeouts":0,</span><br><span class="line">        "http_failures":0,</span><br><span class="line">        "interval":0</span><br><span class="line">    &#125;,</span><br><span class="line">    "http_path":"/",</span><br><span class="line">    "timeout":1,</span><br><span class="line">    "healthy":&#123;</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            200,</span><br><span class="line">            <span class="number">302</span></span><br><span class="line">        ],</span><br><span class="line">        "interval":0,</span><br><span class="line">        "successes":0</span><br><span class="line">    &#125;,</span><br><span class="line">    "concurrency":10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;kong会根据配置定期对后端服务节点机器调用检查url进行检查，如果检查超时或HTTP返回码满足失败条件的次数超过限制，负载均衡器会把该节点标记为不可用。 </p><p>&emsp;&emsp;被动检查需要设置失败判断码、失败判断次数、成功判断码、成功判断次数、超时判断次数等。<br>&emsp;&emsp;kong默认的被动检查配置如下(这个配置不会启用被动检查，因为tcp_failures、timeouts、http_failures和successes都被设成了0)：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">"passive":&#123;</span><br><span class="line">    "unhealthy":&#123;</span><br><span class="line">        "http_failures":0,</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            429,</span><br><span class="line">            500,</span><br><span class="line">            <span class="number">503</span></span><br><span class="line">        ],</span><br><span class="line">        "tcp_failures":0,</span><br><span class="line">        "timeouts":0</span><br><span class="line">    &#125;,</span><br><span class="line">    "healthy":&#123;</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            200,</span><br><span class="line">            201,</span><br><span class="line">            202,</span><br><span class="line">            203,</span><br><span class="line">            204,</span><br><span class="line">            205,</span><br><span class="line">            206,</span><br><span class="line">            207,</span><br><span class="line">            208,</span><br><span class="line">            226,</span><br><span class="line">            300,</span><br><span class="line">            301,</span><br><span class="line">            302,</span><br><span class="line">            303,</span><br><span class="line">            304,</span><br><span class="line">            305,</span><br><span class="line">            306,</span><br><span class="line">            307,</span><br><span class="line">            <span class="number">308</span></span><br><span class="line">        ],</span><br><span class="line">        "successes":0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;kong在跟后端机器进行通信的过程中，判断其返回码，有无超时。然后根据配置决定是否对节点进行标记。     </p><p>&emsp;&emsp;由于被动检查的操作是在负载均衡器里面进行，attach_healthchecker_to_balancer里面对负载均衡器设置了report_http_status和report_tcp_failure方法，这2个方法会在转发请求的时候被调用，把请求结果通知给健康检查器，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L249" target="_blank" rel="noopener">balancer.lua:249</a>。<br>&emsp;&emsp;这里要注意下如果被动检查把一个节点标记为不可用的话，即使该节点已经恢复了，kong也不会自动地把该节点添加进balancer中。需要用户手动调用一个管理接口进行恢复，见<a href="https://getkong.org/docs/0.12.x/health-checks-circuit-breakers/#passive-health-checks-circuit-breakers" target="_blank" rel="noopener">文档</a>。  </p><p>&emsp;&emsp;构造完健康检查器后，调用populate_healthchecker方法把负载均衡器中节点添加到健康检查器中。然后调用attach_healthchecker_to_balancer监听健康检查器的事件：healthchecker.events.healthy和healthchecker.events.unhealthy，并设置回调方法。回调方法就是根据健康检查器的事件类型，在负载均衡器中把后端节点标记为可用或不可用，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L229" target="_blank" rel="noopener">balancer.lua:229</a>。 </p><h4 id="选择target"><a href="#选择target" class="headerlink" title="选择target"></a>选择target</h4><p>&emsp;&emsp;当请求匹配出一条路由规则之后，就会在该规则下面的target中选一个目标实例进行转发。目标实例的选择发生在kong.access()的后置handler中，调用balancer.execute方式进行选择。target的选择全权委托给了resty.dns.balancer对象，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L689" target="_blank" rel="noopener">balancer.lua:689</a>。<br>&emsp;&emsp;选择target的算法是带权重的round-robins。普通的round-robins算法把所有候选的target放入一个数组中，确定一个数组的起始元素(一般取第一个)。之后每次选择的时候按顺序往后选一个，到末尾时再从头开始遍历。带权重的round-robins算法相似，也是遍历数组。只不过数组的大小会远远超过target的数量，resty.dns.balancer初始化的时候wheelSize就是指定这个数组的大小。wheelSize和每个target的权重值确定一个target在数组中分配的数量，然后随机选择数组的位置进行放入。</p><h2 id="集群间数据同步"><a href="#集群间数据同步" class="headerlink" title="集群间数据同步"></a>集群间数据同步</h2><h3 id="概览-3"><a href="#概览-3" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;kong的代码运行于nginx的worker进程中。kong对数据的修改会在一个worker中进行，数据被修改后需要通知给本地的其他worker进程和其他机器上的worker进程。kong使用的进程间通信主要方式有：1. 本机间通信-共享内存 2. 跨机器通信-数据库。  </p><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>&emsp;&emsp;kong的数据存储在数据库中，同时在缓存中保留一份。当数据库的中的数据被修改时，需要发出相应的事件通知其他worker。其他worker接收事件后，删除缓存中对应的数据。下次从缓存读数据时发现没有的话，就从数据库加载出来。<br>&emsp;&emsp;事件分为本地事件和集群事件。本地事件用于通知在一台机器上的worker，集群事件用于通知在多台机器上的worker。</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>&emsp;&emsp;本地事件通过共享内存实现。kong实现了一套基于nginx共享内存的事件发布-订阅机制，源码见仓库<a href="https://github.com/Kong/lua-resty-worker-events" target="_blank" rel="noopener">lua-resty-worker-events</a>。该包提供post_local方法在worker进程内进行事件发布，提供post方法在同属于一台机器上的worker进程间进行事件发布。这2个方法需要指定source和event来确定事件源。<br>&emsp;&emsp;kong的数据访问层<a href="https://github.com/Kong/kong/blob/0.12.1/kong/dao/dao.lua" target="_blank" rel="noopener">dao.lua</a>封装了insert、update和delete三个对数据操作的方法。这三个方法分别会使用post_local发出source为dao:crud，event为insert、delete、update的数据增、删、改的事件。事件的数据格式如下:  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   schema    = self.schema, <span class="comment">--表名</span></span><br><span class="line">   operation = <span class="string">"create"</span>, <span class="comment">--操作类型</span></span><br><span class="line">   entity    = res, <span class="comment">--数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;worker进程启动的时候会在init_worker阶段注册这些事件的订阅方法，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/handler.lua#L97" target="_blank" rel="noopener">handler.lua:97</a>。订阅方法中把所有的dao:crud事件按表名称使用post_local再进行分发。所以从dao:crud分发的事件如下:  </p><ul><li>source=crud, event=apis<br>这个事件会通知所有的worker(包含不同机器)apis数据的修改。这里对缓存中对key为router:version进行invalidate操作会发送一条channel=invalidations集群事件。  </li><li>source=crud, event=targets<br>这个事件会通知所有的worker(包含不同机器)targets数据的修改。使用cluster_events:broadcast方法发送一条channel=balancer:targets集群事件。</li><li>source=crud, event=upstreams<br>这个事件会通知所有的worker(包含不同机器)upstreams数据的修改。使用cluster_events:broadcast方法发送一条channel=balancer:upstreams集群事件。</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>&emsp;&emsp;集群事件通过数据库实现。数据库表cluster_events存放用于集群间分发的事件。cluster_events表结构如下:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cluster_events (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 标识生成事件的节点id</span></span><br><span class="line">  node_id <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件产生时间，精确到毫秒 </span></span><br><span class="line">  <span class="keyword">at</span> <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件生效时间，精确到毫秒</span></span><br><span class="line">  nbf <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件过期时间，精确到毫秒</span></span><br><span class="line">  expire_at <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件类型</span></span><br><span class="line">  channel <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件数据</span></span><br><span class="line">  <span class="keyword">data</span> <span class="built_in">varchar</span>(<span class="number">10000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> cluster_events_at_idx (<span class="keyword">at</span>),</span><br><span class="line">  <span class="keyword">KEY</span> cluster_events_channelt_idx (channel)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure> <p>channel的类型有:  </p><ul><li>invalidations<br>表示路由规则、插件配置的变更</li><li>balancer:targets<br>表示负载均衡的targets列表发生变更</li><li>balancer:upstreams<br>表示upstream对象发生变更</li><li>balancer:post_health<br>表示target的健康状态发生变更。由于被动健康检查拉出实例后，kong不会在对该实例进行自动拉入，需要通过该事件来拉入实例。  </li></ul><p>&emsp;&emsp;调用cluster_events:broadcast方法会往cluster_events表中新增一条记录。在init_worker阶段通过调用cluster_events:subscribe会开启一个定时器，定时查询出cluster_events表中新增的记录。这里要注意的是同一台机器上只会有一个worker进程会对数据库进行查询(通过加锁实现，代码见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/cluster_events.lua#L303" target="_blank" rel="noopener">cluster_events:303</a>)，查询出来后再通过共享内存的方式通知给这台机器上的其他worker。<br>&emsp;&emsp;配置参数db_update_frequency确定查询数据库的间隔，默认为5秒。数据范围根据at字段是否落在(起始时间, 结束时间]确定。起始时间第一次设置在init_worker阶段，调用ngx.now()获取当前时间(精确到毫秒)并放入key为cluster_events:at的共享内存中。之后抢到锁的worker会从共享内存中取出该时间，该时间需要减去db_update_propagation + 0.001来确定起始时间，以防止事件丢失。配置参数db_update_propagation默认为0。结束时间取ngx.now()的值。查询成功后会把结束时间覆盖之前的起始时间，并把该事件分发到本机的其他worker。对于设置了nbf的事件，kong如果发现还没到生效时间，就会通过ngx.timer设置一个定时器延后分发该事件。  </p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><h3 id="概览-4"><a href="#概览-4" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;kong的插件可以在不修改kong本身源码的情况下方便地添加一些功能。插件不仅可以处理请求，还可以定义API，操作数据库。kong本身提供了许多插件，支持鉴权认证、安全控制、流量调控和请求报文转换等。见<a href="https://konghq.com/plugins/" target="_blank" rel="noopener">plugins list</a>   </p><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>&emsp;&emsp;每个插件都需要放置在plugins目录下。这里有个<a href="https://github.com/Kong/kong/blob/0.12.1/kong/plugins/base_plugin.lua" target="_blank" rel="noopener">base_plugin.lua</a>文件，定义了一个每个插件都需要去继承的基类。该基类定义了一些每个子类都需要去实现的方法，kong在每个执行阶段会调用。插件需要定义一个handler.lua文件，在这个文件里面去实现子类。此外还需要定义一个schema.lua文件，在这里定义每个插件的配置数据。<br>&emsp;&emsp;在nginx的master启动阶段，会扫描plugins目录下面的所有插件，加载handler.lua和schema.lua中定义的模块，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/init.lua#L78" target="_blank" rel="noopener">kong/init.lua:78</a>。<br>&emsp;&emsp;数据库中的plugins表定义了需要启用的插件。只有在这张表里面存在的插件，并且是开启状态的才会被使用。<br>&emsp;&emsp;插件还可以定义一个api.lua文件，用于暴露一些api接口。如oauth2插件。kong在nginx的配置文件里面开启了8001端口，所有的管理api都暴露在这个端口上。它会调用kong/init.lua中的serve_admin_api方法，使用lapis模块加载api/routes/init.lua，初始化管理接口。这里也会加载插件的api.lua，加载插件的接口，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/api/init.lua#L158" target="_blank" rel="noopener">api/init.lua:158</a>。<br>&emsp;&emsp;在每个请求的执行阶段，都会先执行kong的前置处理方法，然后遍历所有启用的插件执行每个阶段对应的方法。如果读者看过base_plugin的文件话会发现基本上所有的方法都会传一个conf参数。这个就是在plugins表中定义的每个插件需要用到的配置。遍历插件的时候会从缓存里面加载插件配置，如果缓存失效就会从数据里面重新加载一遍。我们可以触发invalidations集群事件来动态的更新插件配置。见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/plugins_iterator.lua" target="_blank" rel="noopener">core/plugins_iterator.lua</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;kong是一个基于nginx和OpenResty模块构建的API网关服务。提供http请求路由，后端服务负载均衡以及通过丰富的插件提供认证鉴权、流量调控、日志监控等功能。该网关目前应用在全球著名的API管理站点&lt;a href=&quot;https://market.mashape.com/explore?page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mashape&lt;/a&gt;上。&lt;br&gt;&amp;emsp;&amp;emsp;nginx是一个采用异步I/O，事件驱动的高性能Web服务器，也可以作为在企业内部提供基于http rpc的反向代理和负载均衡器。由于nginx的配置都是以静态文件的方式提供，而且nginx一般都是多台部署，导致nginx的运维管理变得比较复杂。许多运维的小伙伴都会写一些运维脚本，自动通过ssh命令远程连接到服务器去做一些配置更新的操作。&lt;br&gt;&amp;emsp;&amp;emsp;笔者所在公司也开发过一个基于nginx的软负载中心。用户可以在平台上为自己的服务配置反向代理以及负载均衡策略。用户所有的操作都会打包成一次对nginx配置的修改。修改指令会发送到每台nginx部署的一个agent上，最后由agent完成nginx配置文件的更新。&lt;br&gt;&amp;emsp;&amp;emsp;这些方法虽然可以达到自动化的管理nginx，但是本质上还是通过配置文件的方式去改变nginx的一些固定行为。在企业里面，特别是互联网公司常常需要定制一些功能。虽然可以为nginx开发一些模块，但是门槛较高，需要对nginx源码级的掌握。OpenResty为nginx引入的LuaJIT和lua-nginx-module，使我们可以在nginx的各个执行阶段编写一些lua脚本，极大地扩展了nginx的功能。OpenResty的作者已经用lua开发了许多工具库，使得我们可以在nginx中访问MySQL、Memcached、Redis。kong在此基础上实现了一个API网关服务。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="API网关" scheme="http://techblog.ppdai.com/tags/API%E7%BD%91%E5%85%B3/"/>
    
      <category term="nginx" scheme="http://techblog.ppdai.com/tags/nginx/"/>
    
      <category term="openresty" scheme="http://techblog.ppdai.com/tags/openresty/"/>
    
      <category term="kong" scheme="http://techblog.ppdai.com/tags/kong/"/>
    
      <category term="lua" scheme="http://techblog.ppdai.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>老司机的技术选型哲学</title>
    <link href="http://techblog.ppdai.com/2018/03/26/20180326/"/>
    <id>http://techblog.ppdai.com/2018/03/26/20180326/</id>
    <published>2018-03-26T12:22:22.000Z</published>
    <updated>2018-05-28T09:15:59.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>技术选型是一个很热门的话题，最近我看到自己的微信朋友圈有好几篇关于技术选型的文章，读者对这类主题的热情很高。在技术组织内部，技术人员经常会面临技术选型问题，有时候，技术选型还常常牵扯好几波干系人，相互之间还会产生争议，有的甚至还可能发展到派系斗争的地步。即便像我自己，已经有十几年研发和架构经验的老司机，不管是工作还是业余，有很大部分时间的思考都是深陷在A技术和B技术的利弊权衡之中，不能自拔。无论如何，技术选型说小了关乎项目和团队成败，说大了关乎企业业务的发展，不可小觑。</p><p>本文所表达的技术选型理念应该是具体技术无关的，但是由于我个人的背景更偏向互联网后端的研发和架构，所以本文的视角更偏向后端技术的选型。</p><a id="more"></a><h2 id="二、软件的本质复杂性"><a href="#二、软件的本质复杂性" class="headerlink" title="二、软件的本质复杂性"></a>二、软件的本质复杂性</h2><p>近年，云计算、微服务、容器和DevOps等新技术和理念层出不穷，技术人员对各种新技术的追捧热情也空前高涨，各种新技术微信讨论群也如雨后春笋般冒了出来。这是一个好现象，说明我们的开发人员多了，技术环境也日趋成熟，有点百花齐放的感觉。同时也让我有一点担忧，我担忧的是纯技术和工具论的抬头，也就是太过专注技术，认为技术可以搞定一切，反而忽略了软件研发的本质复杂性。回想当年，自己也曾是这样的技术狂热分子，EJB刚出来的时候，我为EJB摇旗呐喊，Spring出来的时候，我也曾一度是该技术的死忠，简单认为这些技术是银弹可以帮助解决所有的复杂性问题。</p><p>1986年，人月神话的作者Brooks就提出，软件的本质复杂性（Essential Complexity）存在于复杂的业务领域中（用技术的话讲是业务领域建模复杂性），技术仅是辅助工具，它解决的问题是帮助将业务领域问题映射转换成软件实现，只解决次要复杂性（Accidental Complexity）。作者同时指出，由于软件本质的复杂性，真正的银弹并不存在；也断言在十年内，没有任何一项技术或者方法可使软件工程的生产力提高一个数量级。30年前作者提出的论断，今天依然闪烁智慧的光芒。人月神话已经出了40周年纪念版了，堪称软件工程的圣经，建议所有从事软工行业的朋友学习。除了业务和技术，我还想强调软件的本质复杂性同时隐含在企业的人、组织、流程和管理中，不容忽视。</p><p>架构师只有深刻理解软件的本质复杂性，才能站在解决实际业务问题的角度，更好的做出技术选型，否则易陷入唯技术工具论的陷阱。</p><p><img src="/2018/03/26/20180326/mythical_man_month.jpg" alt="mythical man month"></p><h2 id="三、使用成熟的技术"><a href="#三、使用成熟的技术" class="headerlink" title="三、使用成熟的技术"></a>三、使用成熟的技术</h2><p>大部分公司都是商业组织，不是科研机构或者纯软件研发机构。商业组织使用技术是为了解决当下的业务问题，他们更应该使用成熟稳定的技术。</p><p>如下图，技术的使用有明显的生命周期，早期有创新者和早期使用者采用，我把这个阶段称为试水趟坑期，也就是说这个阶段技术不是很成熟稳定的，虽然尝新者可能占据一定的技术领先优势，但是他们常常需要以踩坑填坑作为代价；如果这项技术经过早期验证则会跨越鸿沟进入早期大众阶段，这个阶段技术会逐渐走向成熟，处于上升期，坑逐渐被填平，技术被大众所采纳；之后技术缓慢经过末期大众阶段，最终走向滞后期，一直到生命周期的结束退出历史舞台。</p><p><img src="/2018/03/26/20180326/tech_adoption.jpg" alt="technology adoption life cycle"></p><p>技术选型的一大智慧是不要盲目追求新技术，老老实实采用成熟稳定的技术，让那些喜欢追新的人去踩坑😊，等这项技术跨越鸿沟，进入早期大众阶段，你再择机投入，这样最保险和高效。当然作为技术人员，对新技术保持敏锐，提前预研是完全OK的，但是投入生产的话还是成熟稳定第一。</p><h2 id="四、少即是多"><a href="#四、少即是多" class="headerlink" title="四、少即是多"></a>四、少即是多</h2><p>一项新技术既有学习成本，又有维护（定制、监控、管理和运维）成本，新技术引入很容易，学好用好运维好却很难。一个不严格把控技术栈数量的公司，开发人员常常会各自为政，随意引入新技术，造成技术栈散乱，学习和维护成本高，技术栈知识无法共享，技术体系无法建立等问题，严重的会极大影响研发效率和业务规模化能力。</p><p>以我本人专注的后端基础框架领域为例，技术栈散乱还会直接影响系统稳定性，因为技术组件和工具太多，无法统一埋点和建立完善的监控体系。当业务量发展到一定规模，技术栈散乱还会给系统扩容跨机房迁移等带来巨大障碍。</p><p>在一些成熟的互联网公司，比如国内的阿里，国外的Netflix和eBay等公司，这些公司虽然财力和资源丰富，但是他们的核心技术栈（比如主流开发语言，框架和数据存储等）的数量同样是受到严格把控的。</p><p>新技术引入的基本原则就是少即是多，能不引入新技术尽量不要引入新技术，确实需要引入的话，也要有相应的新技术引入管理流程（一般由公司的技术或者架构委员会制定和把控）。</p><h2 id="五、技术的先决条件"><a href="#五、技术的先决条件" class="headerlink" title="五、技术的先决条件"></a>五、技术的先决条件</h2><p>技术引入常常是有一些先决条件的，比方说最近比较热的微服务架构，按照马丁福勒的说法，微服务有如下先决条件：</p><ul><li>快速的环境提供能力（Provisioning）能力（通常指IAAS层能力），</li><li>基本的监控能力</li><li>快速的发布能力</li><li>初步的DevOps文化</li></ul><p>马丁特别指出“你必须长足够高才能考虑微服务”，在这些先决条件没有满足之前，直接推行微服务会面临巨大落地挑战。</p><p><img src="/2018/03/26/20180326/tech_prerequisite.jpg" alt="tech prerequisite"></p><p>同样，容器技术的引入对应用也是有要求的（参考[<a href="#appendix">附录18.1</a>] ~ 12 Factor App），而DevOps研发模式的引入不仅对基础技术和架构，研发人员技能，甚至组织架构和企业文化都是有很高要求的，在没有满足先决条件前，这些新技术或研发模式都会面临巨大的落地挑战。</p><p>作为管理者或者架构师，在引入一项新技术之前，要充分调研了解新技术的先决条件，不能盲目引入。对于确实需要引入但是目前还不满足先决条件的，需要做好阶段性规划，先打好基础，再适时引入新技术。</p><h2 id="六、来自大公司的技术"><a href="#六、来自大公司的技术" class="headerlink" title="六、来自大公司的技术"></a>六、来自大公司的技术</h2><p>大公司采用的技术，未必适合中小公司。大公司有足够的资源、人力和时间，可以投入一些前沿和重量级的技术（在BAT级别公司，为重量级技术投入几十甚至百人以上的研发团队是很正常的事），但是中小公司资源有限，不能盲目跟风，应该选择和自己发展阶段相适应的技术，否则不仅不能帮助业务发展，反而会给业务发展带来阻碍。</p><h2 id="七、技术的文化特性"><a href="#七、技术的文化特性" class="headerlink" title="七、技术的文化特性"></a>七、技术的文化特性</h2><p>技术常常带有文化特性的，在国外流行的技术，在国内未必流行。一个例子是如Scala这样的函数式语言，Scala在国外互联网公司是有一定流行度的（Twitter、Linkedin等），国内虽然有不少簇拥者，但是始终只是小众，无法流行，究其原因，国外很多大学教授的第一门编程语言是采用函数式语言的（例如美国Berkeley大学的CS61A是基于Scheme函数式语言），国内大学几乎清一色采用C/C++/Java等命令式语言作为第一门编程语言。也就是说函数式语言在国外是有文化基础的，所以容易流行，国内没有这样的文化基础，所以难以流行。</p><p>我们在选型的时候，尽量采用在国内有文化基础，已经落地开花的技术，盲目追求国外新技术有可能文化不适应反而难于落地。</p><p>同样的，在A公司流行的技术，在B公司也未必流行。比方说BAT三家公司所采用和后面演化出来的技术栈就明显不同，这同样和三家公司不同的业务领域和文化基因有关系。我们在做技术选型的时候，也要考虑公司的文化特性，如业务模式、已有技术生态和开发人员技能等现实情况。</p><h2 id="八、开源还是第三方软件提供商的技术"><a href="#八、开源还是第三方软件提供商的技术" class="headerlink" title="八、开源还是第三方软件提供商的技术"></a>八、开源还是第三方软件提供商的技术</h2><p>互联网时代，传统的企业软件供应商开始明显地走下坡路，企业越来越多的采用开源技术来开发他们的业务系统，开源软件具有如下优势：</p><ol><li>成本，商业软件一般有昂贵的license费用；</li><li>避免供应商绑定(vendor lockin)；</li><li>灵活的定制能力，现代企业需要灵活的软件定制能力以应对快速变化的用户需求，商业闭源软件常常缺乏这种能力；</li><li>社区和生态，投资具有良好社区和生态的开源技术是企业技术选型的最佳实践。</li></ol><p>即使是开源软件，这里面有一个很重要的闭环问题。有些开源软件是一线互联网公司成功落地后再开源出来的，比如阿里的dubbo，点评的CAT，这些公司本身有场景，内部大量使用，也就是说内部已经形成反馈闭环，开源出来和社区又形成了一个更大的反馈闭环。有一些第三方软件供应商提供的开源软件，其实他们本身是没有业务场景的（或者场景非常有限），主要靠社区使用后才能形成反馈闭环，对于这类开源软件的使用需要谨慎，如果选择的话，可能需要一起帮忙踩坑形成社区反馈闭环。</p><h2 id="九、使用能掌控的技术"><a href="#九、使用能掌控的技术" class="headerlink" title="九、使用能掌控的技术"></a>九、使用能掌控的技术</h2><p>技术和武器一样，并不是说越先进越好。就像航空母舰和F117这样的尖端武器，确实非常厉害，但是掌握和部署运维这些武器的成本非常之高，如果你的团队没有足够的能力运维和掌控这样的武器，那么这些武器摆在家里充其量只能是摆设，不能形成战斗力，有时甚至还会拖累业务。</p><p>在大数据领域重量级武器尤其多（Hadoop, HBase, Spark, Storm…），很多产品既消耗机器资源，部署和运维也非常复杂，如果某种重量级武器被应用在关键业务上，一旦出问题，团队能不能hold住是要重点考虑的，否则可能会死得很难看。架构师需要根据业务阶段规模，团队规模和技能水平，综合评估后再考虑引入，如果团队能力还不足以掌控某种重量级技术，则可以先从轻量级技术开始。</p><h2 id="十、剑要交给懂得挥舞它的人"><a href="#十、剑要交给懂得挥舞它的人" class="headerlink" title="十、剑要交给懂得挥舞它的人"></a>十、剑要交给懂得挥舞它的人</h2><p>同一种技术，不同的人使用，可能会得出完全相反的结论。比如Cassandra这种NoSql分布式数据库，在Netflix有比较成功的应用，Netflix从2010开始将系统迁移到AWS云中，并开始将大部分业务数据从传统Oracle数据库迁移到Cassandra上，Netflix的前架构总监Adrian Cockcroft把他们技术升级的一大成功功劳归结为采用了Cassandra这种天然支持跨数据中心的分布式数据库。但是，在2012年时候，Digg在网站改版升级过程中也试图将传统Mysql数据库迁移到Cassandra Nosql数据库，结果导致Digg网站问题频发，最后技术副总裁John Quinn主动卷铺盖走人。事后，有人将问题归结为Cassandra，这就是著名的Digg使用Cassandra遭遇滑铁卢事件。有人在Quora上发帖提问“Is Cassandra to blame for Digg v4’s technical failures？”[<a href="#appendix">附录18.2</a>]，回帖中有知情人士出来澄清：把Digg网站升级失败归结为Cassandra完全是转移注意力（red herring），背后的真正原因是工程管理和架构的问题（poor engineering management and architecture），简单讲就是人的问题。</p><p>我曾经在2013年左右在携程框架部工作，当时有一个很重要的框架产品叫分布式数据访问层DAL，很多团队都跃跃欲试要做，但是当时的CTO一直没有正式启动这个项目，理由是没有合适的人。这个事情拖了有一年之久才找到合适的人，这个项目才启动并逐步落地，现在已经是携程框架的关键基础设施，承载携程大部分数据库访问流量。</p><p>对于一些重量级的，处于业务关键链路上的产品，如果它重要但不紧急的话，一定要找到并交给能搞定它的人。把一个重要产品交给一个不合适的人，不仅不能解决问题，后续还常常会制造问题。设想一下业务的关键链路上的某个关键产品质量不过关，问题频发，但是业务已经跑在上面无法简单替换，这是让人很无奈的事情，很多架构老司机对此场景应该深有体会吧。</p><h2 id="十一、浪费是创新的副产品"><a href="#十一、浪费是创新的副产品" class="headerlink" title="十一、浪费是创新的副产品"></a>十一、浪费是创新的副产品</h2><p>即使在同一个公司中，在主流技术栈的基础上，不同团队适当引入一些不同的技术栈，比如一个公司主流的技术栈是Java，有些前端团队会尝试用Nodejs开发应用，有些大数据团队会采用Python开发应用（Python里头有很多数据分析库）。这些做法和第二点提出的少即是多并不矛盾，根据业务场景的需要，适当引入一些互补的技术栈，适度冗余可以促进团队创新。</p><p>再举个例子，阿里在发展的过程中，曾经发展出两套技术体系，一套是淘宝体系，一套是B2B体系。有一段时间内，两套体系并行发展，团队之间既竞争也相互借鉴，形成一个良性竞争的技术生态。据说Dubbo最早就是B2B搞出来的，淘宝后面又搞了一套HSF（未开源），Dubbo和HSF之间相互借鉴所以功能比较类似，阿里在2014年上市前对技术栈进行了整合，集团统一使用HSF，Dubbo则继续活跃在开源社区，成为中国开源软件的一个传奇，它的成功一方面源自阿里技术的沉淀，另一方面也是B2B和淘宝相关团队思路碰撞融合的结果。</p><h2 id="十二、技术的宗教信仰"><a href="#十二、技术的宗教信仰" class="headerlink" title="十二、技术的宗教信仰"></a>十二、技术的宗教信仰</h2><p>很多技术人员对他们投入时间最多最熟悉的技术栈比较热衷，有些甚至能上升到宗教信仰的程度，不同派系还会有相互鄙视的情况出现（据说PHP是最被鄙视的语言），有的还会发展到派系争斗的地步。之前我在一家互联网公司，在容器PaaS平台选型上出现了两个派系，分别被戏称为K党和M党，K党主张引入谷歌推的Kubernetes，M党主张基于Mesos做定制，两拨人都非常坚持互不相让，争得不可开交。</p><p>其实我个人对技术的宗教信仰是非常排斥的，它是一种技术视野狭隘的表现，技术本身没有绝对的好坏之分，只有适用场景和利弊之分。但是，技术的宗教信仰是一种客观存在，有经验的架构师在做技术选型时需要考虑这一层面的因素。</p><h2 id="十三、通过背书做技术选型"><a href="#十三、通过背书做技术选型" class="headerlink" title="十三、通过背书做技术选型"></a>十三、通过背书做技术选型</h2><p>和一线资深的架构师或者技术专家交流，获取技术选型的专家建议，是一种比较靠谱的技术选型策略。专家是一种背书，他们踩坑无数才成为专家，对很多技术有一手的实战经验，是真正know how的人，所以他们给出的建议一般都比较接地气。</p><p>大公司是一个很好的背书，比方说Google，当初它推出Kubernetes的时候，其实我一开始看过架构设计之后是对这个产品嗤之以鼻的。但是Google的强大背书和号召力摆在那里，用户深信Google用脚投票，一开始架构设计不好不是根本性问题，只要有足够的用户形成社区闭环，这个产品就会不断长好长大。目前K8S已经基本垄断了容器PaaS平台市场，它的成功很大程度归结为Google公司的背书影响力。所以，绑着技术型大公司这个背书做技术选型，大概率不至于大错（当然不是绝对）。</p><p>Github上的星的数量也是一个重要的技术选型参考，同时还有项目代码和文档更新频度（尤其是近期），这些指标直接反应开源项目的社区活跃度和生命力。</p><h2 id="十四、实践出真知"><a href="#十四、实践出真知" class="headerlink" title="十四、实践出真知"></a>十四、实践出真知</h2><p>实际评估一项技术时，最靠谱的做法还是详细研究其文档，做一些样例和测试，对性能有要求的则必须实际做充分压力测试获得真实性能数据。对于开源的产品，如果处在业务的关键链路上，则建议把代码拉下来通读梳理一把，深入理解其内部设计和架构，有的还需要根据企业业务场景适当做一些定制。</p><p>通过初步评估，仍需要寻找一定数量非关键试点项目（pilot project）做试水躺坑，经过初步生产验证，才可以考虑逐步扩大生产普及的规模。</p><p>实践出真知，对于那些长期在一线实战和积累的架构师，他们最终将获得良好的技术选型的sense和对新技术的敏锐性。</p><h2 id="十五、技术的落地"><a href="#十五、技术的落地" class="headerlink" title="十五、技术的落地"></a>十五、技术的落地</h2><p>简单回顾下我国辽宁号航母的历史：1999年中国购买了瓦良格号，于2002年3月拖回大连港，2005年4月开始由中国海军继续建造改进，2012年9月正式更名辽宁号，交付中国人民解放军海军，2013年11月，辽宁舰从青岛远赴中国南海展开为期47天的海上综合演练，标志着辽宁号航母开始具备海上编队战斗群能力。我国前前后后花费超过10年才让辽宁号航母初步形成战力能力。</p><p>技术和武器一样，你引入一个技术是一码事，真正落地形成战斗力或者说产生业务价值完全是另外一码事。技术一般有落地周期：引入，定制改造，小规模试点，再到逐步扩大生产规模，这个周期可长可短，对于一些基础性和重量级的技术，或者涉及大规模遗留系统升级改造的技术，一般周期比较漫长（可能时间跨度长达1年甚至几年），对于这类技术的引入和落地，架构师需要高屋建瓴，通盘考虑，制定落地计划，分阶段推进技术的落地。</p><h2 id="十六、定制、自研还是购买"><a href="#十六、定制、自研还是购买" class="headerlink" title="十六、定制、自研还是购买"></a>十六、定制、自研还是购买</h2><p>这个问题比较复杂，很难一概而论，和企业的业务和团队规模，架构甚至文化等诸多因素有关系。我个人遵循的两个简单原则分别是：</p><ol><li>如果不是你最擅长，也提供不了差异化的竞争优势的技术则直接用开源或者购买。小心Not Invented Here症状，避免重复造轮子，始终牢记达成业务目标才是重点。</li><li>当企业的业务和团队规模达到一定阶段，对于处在业务关键链路上的核心技术，必须要有一定的定制甚至自研能力。创业公司尽量用开源或者购买云服务，验证业务模式是第一优先；当你的业务模式获得验证，业务和团队达到一定规模，则需逐步考虑对核心业务链路上的技术进行定制甚至自研，以获得更大的灵活性；如果你成长到接近BAT那个量级，那么大部分核心技术必然是定制甚至自研的，否则无法支撑那个规模。</li></ol><h2 id="十七、写在最后"><a href="#十七、写在最后" class="headerlink" title="十七、写在最后"></a>十七、写在最后</h2><p>本文仅限个人经验视角，技术选型理念仅供参考借鉴。每个企业的具体上下文（业务场景，团队组织，技术架构等）各不相同，每个架构师的背景经验也各不相同，大家要结合实际自己做出选型，没有最好的技术，只有相对较合适的技术。另外，好的技术选型是相互借鉴甚至PK出来的，欢迎大家讨论，给出自己的技术选型思考。</p><h2 id="十八、附录"><a href="#十八、附录" class="headerlink" title="十八、附录"></a><a name="appendix">十八、附录</a></h2><ol><li><a href="https://12factor.net/" target="_blank" rel="noopener">12 Factor App</a></li><li><a href="https://www.quora.com/Is-Cassandra-to-blame-for-Digg-v4s-technical-failures" target="_blank" rel="noopener">2.    Is Cassandra to blame for Digg v4’s technical failures?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;技术选型是一个很热门的话题，最近我看到自己的微信朋友圈有好几篇关于技术选型的文章，读者对这类主题的热情很高。在技术组织内部，技术人员经常会面临技术选型问题，有时候，技术选型还常常牵扯好几波干系人，相互之间还会产生争议，有的甚至还可能发展到派系斗争的地步。即便像我自己，已经有十几年研发和架构经验的老司机，不管是工作还是业余，有很大部分时间的思考都是深陷在A技术和B技术的利弊权衡之中，不能自拔。无论如何，技术选型说小了关乎项目和团队成败，说大了关乎企业业务的发展，不可小觑。&lt;/p&gt;
&lt;p&gt;本文所表达的技术选型理念应该是具体技术无关的，但是由于我个人的背景更偏向互联网后端的研发和架构，所以本文的视角更偏向后端技术的选型。&lt;/p&gt;
    
    </summary>
    
      <category term="技术管理" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="技术选型" scheme="http://techblog.ppdai.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>微服务2.0技术栈选型手册</title>
    <link href="http://techblog.ppdai.com/2018/03/25/20180325/"/>
    <id>http://techblog.ppdai.com/2018/03/25/20180325/</id>
    <published>2018-03-25T11:13:47.000Z</published>
    <updated>2018-05-28T09:15:37.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>2014年可以认为是微服务1.0的元年，当年有几个标志性事件，一是Martin Fowler在其博客上发表了“Microservices”一文，正式提出微服务架构风格；二是Netflix微服务架构经过多年大规模生产验证，最终抽象落地形成一整套开源的微服务基础组件，统称NetflixOSS，Netflix的成功经验开始被业界认可并推崇；三是Pivotal将NetflixOSS开源微服务组件集成到其Spring体系，推出Spring Cloud微服务开发技术栈。</p><p>一晃三年过去，微服务技术生态又发生了巨大变化，容器，PaaS，Cloud Native，gRPC，ServiceMesh，Serverless等新技术新理念你方唱罢我登场，不知不觉我们又来到了微服务2.0时代。基于近年在微服务基础架构方面的实战经验和平时的学习积累，我想总结并提出一些构建微服务2.0技术栈的选型思路，供各位在一线实战的架构师、工程师参考借鉴。对于一些暂时还没有成熟开源产品的微服务支撑模块，我也会给出一些定制自研的设计思路。</p><a id="more"></a><h2 id="二、选型准侧"><a href="#二、选型准侧" class="headerlink" title="二、选型准侧"></a>二、选型准侧</h2><p>对于技术选型，我个人有很多标准，其中下面三项是最重要的:</p><h3 id="1-生产级"><a href="#1-生产级" class="headerlink" title="1. 生产级"></a>1. 生产级</h3><p>我们选择的技术栈是要解决实际业务问题和上生产抗流量的（选择不慎可能造成生产级事故），而不是简单做个POC或者Demo展示，所以生产级（Production Ready），可运维（Ops Ready），可治理，成熟稳定的技术才是我们的首选；</p><h3 id="2-一线互联网公司落地产品"><a href="#2-一线互联网公司落地产品" class="headerlink" title="2. 一线互联网公司落地产品"></a>2. 一线互联网公司落地产品</h3><p>我们会尽量采用在一线互联网公司落地并且开源的，且在社区内形成良好口碑的产品，它们已经在这些公司经过流量冲击，坑已经基本被填平，且被社区接受形成一个良好的社区生态（本文附录部分会给出所有推荐使用或参考的开源项目的github链接。）。</p><h3 id="3-开源社区活跃度"><a href="#3-开源社区活跃度" class="headerlink" title="3. 开源社区活跃度"></a>3. 开源社区活跃度</h3><p>Github上的stars的数量是一个重要指标，同时会参考其代码和文档更新频率（尤其是近年），这些指标直接反应开源产品的社区活跃度或者说生命力。</p><p>另外，对于不同业务体量和团队规模的公司，技术选型标准往往是不同的，创业公司的技术选型和BAT级别公司的技术选型标准可能完全不同。本文主要针对日流量千万以上，研发团队规模不少于50人的公司，如果小于这个规模我建议认真评估是否真的需要采用微服务架构。考虑到Java语言在国内的流行度和我个人的背景经验，本文主要针对采用Java技术栈的企业。本文也假定自建微服务基础架构，有些产品其实有对应的云服务可以直接使用，自建和采用云服务各有利弊，架构师需要根据场景上下文综合权衡。</p><h2 id="三、微服务基础架构核心关心点"><a href="#三、微服务基础架构核心关心点" class="headerlink" title="三、微服务基础架构核心关心点"></a>三、微服务基础架构核心关心点</h2><p>下面脑图中芒果色标注的七个模块，我认为是构建微服务2.0技术栈的核心模块，本文后面的选型会分别基于这些模块展开。对于每个模块我也列出一些核心架构关注点，在选择具体产品时，需要尽可能覆盖到这些关注点。</p><p><img src="/2018/03/25/20180325/msa_arch.png" alt="msa arch"></p><p>下图是在参考过华为技术专家王磊的《微服务的设计与生态系统》<a href="#appendix">附录12.46</a>的基础上，结合作者自身的实践调整而来，我想同时分享给一线架构师或者工程师参考，其中粉红色标注的模块是和微服务关系最密切的模块，大家在做技术选型时，可以同时对照这个体系。</p><p><img src="/2018/03/25/20180325/msa_system.png" alt="msa system"></p><h2 id="四、服务框架选型"><a href="#四、服务框架选型" class="headerlink" title="四、服务框架选型"></a>四、服务框架选型</h2><p>服务框架是一个比较成熟的领域，有太多可选项。<strong>Spring Boot/Cloud</strong>[<a href="#appendix">附录12.1</a>]由于Spring社区的影响力和Netflix的背书，目前可以认为是构建Java微服务的一个社区标准，Spring Boot目前在github上有超过20k星。基于Spring的框架本质上可以认为是一种RESTful框架（不是RPC框架），序列化协议主要采用基于文本的JSON，通讯协议一般基于HTTP。RESTful框架天然支持跨语言，任何语言只要有HTTP客户端都可以接入调用，但是客户端一般需要自己解析payload。目前Spring框架也支持Swagger契约编程模型，能够基于契约生成各种语言的强类型客户端，极大方便不同语言栈的应用接入，但是因为RESTful框架和Swagger规范的弱契约特性，生成的各种语言客户端的互操作性还是有不少坑的。</p><p><strong>Dubbo</strong>[<a href="#appendix">附录12.2</a>]是阿里多年构建生产级分布式微服务的技术结晶，服务治理能力非常丰富，在国内技术社区具有很大影响力，目前github上有超过16k星。Dubbo本质上是一套基于Java的RPC框架，当当Dubbox扩展了Dubbo支持RESTful接口暴露能力。Dubbo主要面向Java 技术栈，跨语言支持不足是它的一个弱项，另外因为治理能力太丰富，以至于这个框架比较重，完全用好这个框架的门槛比较高，但是如果你的企业基本上投资在Java技术栈上，选Dubbo可以让你在服务框架一块站在较高的起点上，不管是性能还是企业级的服务治理能力，Dubbo都做的很出色。新浪微博开源的Motan（github 4k stars）也不错，功能和Dubbo类似，可以认为是一个轻量裁剪版的Dubbo。</p><p><strong>gRPC</strong>[<a href="#appendix">附录12.3</a>]是谷歌近年新推的一套RPC框架，基于protobuf的强契约编程模型，能自动生成各种语言客户端，且保证互操作。支持HTTP2是gRPC的一大亮点，通讯层性能比HTTP有很大改进。Protobuf是在社区具有悠久历史和良好口碑的高性能序列化协议，加上Google公司的背书和社区影响力，目前gRPC也比较火，github上有超过13.4k星。目前看gRPC更适合内部服务相互调用场景，对外暴露HTTP RESTful接口可以实现，但是比较麻烦（需要gRPC Gateway配合），所以对于对外暴露API场景可能还需要引入第二套HTTP RESTful框架作为补充。总体上gRPC这个东西还比较新，社区对于HTTP2带来的好处还未形成一致认同，建议谨慎投入，可以做一些试点。</p><h2 id="五、运行时支撑服务选型"><a href="#五、运行时支撑服务选型" class="headerlink" title="五、运行时支撑服务选型"></a>五、运行时支撑服务选型</h2><p>运行时支撑服务主要包括服务注册中心，服务路由网关和集中式配置中心三个产品。</p><p><strong>服务注册中心</strong>，如果采用Spring Cloud体系，则选择<strong>Eureka</strong>[<a href="#appendix">附录12.4</a>]是最佳搭配，Eureka在Netflix经过大规模生产验证，支持跨数据中心，客户端配合Ribbon可以实现灵活的客户端软负载，Eureka目前在github上有超过4.7k星；<strong>Consul</strong>[<a href="#appendix">附录12.5</a>]也是不错选择，天然支持跨数据中心，还支持KV模型存储和灵活健康检查能力，目前在github上有超过11k星。</p><p><strong>服务网关</strong>也是一个比较成熟的领域，有很多可选项。如果采用Spring Cloud体系，则选择<strong>Zuul</strong>[<a href="#appendix">附录12.6</a>]是最佳搭配，Zuul在Netflix经过大规模生产验证，支持灵活的动态过滤器脚本机制，异步性能不足（基于Netty的异步Zuul迟迟未能推出正式版）。Zuul网关目前在github上有超过3.7k星。基于Nginx/OpenResty的API网关<strong>Kong</strong>[<a href="#appendix">附录12.7]</a>目前在github上比较火，有超过14.1k星。因为采用Nginx内核，Kong的异步性能较强，另外基于lua的插件机制比较灵活，社区插件也比较丰富，从安全到限流熔断都有，还有不少开源的管理界面，能够集中管理Kong集群。</p><p><strong>配置中心</strong>，Spring Cloud自带<strong>Spring Cloud Config</strong>[<a href="#appendix">附录12.8</a>]（github 0.75k stars），个人认为算不上生产级，很多治理能力缺失，小规模场景可以试用。个人比较推荐携程的<strong>Apollo</strong>[<a href="#appendix">附录12.9</a>]配置中心，在携程经过生产级验证，具备高可用，配置实时生效（推拉结合），配置审计和版本化，多环境多集群支持等生产级特性，建议中大规模需要对配置集中进行治理的企业采用。Apollo目前在github上有超过3.4k星。</p><h2 id="六、服务监控选型"><a href="#六、服务监控选型" class="headerlink" title="六、服务监控选型"></a>六、服务监控选型</h2><p>主要包括日志监控，调用链监控，Metrics监控，健康检查和告警通知等产品。</p><p><strong>ELK</strong>目前可以认为是日志监控的标配，功能完善开箱即用，<strong>Elasticsearch</strong>[<a href="#appendix">附录12.10</a>]目前在github上有超过28.4k星。<strong>Elastalert</strong>[<a href="#appendix">附录12.11</a>] (github 4k stars)是Yelp开源的针对ELK的告警通知模块。</p><p>调用链监控目前社区主流是点评<strong>CAT</strong>[<a href="#appendix">附录12.12</a>]（github 4.3k stars），Twitter之前开源现在由OpenZipkin社区维护的<strong>Zipkin</strong>[<a href="#appendix">附录12.13</a>]（github 7.5k stars）和Naver开源的<strong>Pinpoint</strong>[<a href="#appendix">附录12.14</a>]（github 5.3k stars）。个人比较推荐点评开源的CAT，在点评和国内多家互联网公司有落地案例，生产级特性和治理能力较完善，另外CAT自带告警模块。下面是我之前对三款产品的评估表，供参考。</p><p><img src="/2018/03/25/20180325/monitoring_evaluation.png" alt="monitoring evaluation"></p><p>Metrics监控主要依赖于时间序列数据库(TSDB)，目前较成熟的产品是StumbleUpon公司开源的基于HBase的<strong>OpenTSDB</strong>[<a href="#appendix">附录12.15</a>]（基于Cassandra的<strong>KariosDB</strong>[<a href="#appendix">附录12.16</a>]也是一个选择，github 1.1k stars，它基本上是OpenTSDB针对Cassandra的一个改造版），OpenTSDB具有分布式能力可以横向扩展，但是相对较重，适用于中大规模企业，OpenTSDB目前在github上有近2.9k星。OpenTSDB 本身不提供告警模块，<strong>Argus</strong>[<a href="#appendix">附录12.17</a>]（github 0.29k星）是Salesforce开源的基于OpenTSDB的统一监控告警平台，支持丰富的告警函数和灵活的告警配置，可以作为OpenTSDB的告警补充。近年也出现一些轻量级的TSDB，如<strong>InfluxDB</strong>[<a href="#appendix">附录12.18</a>]（github 12.4k stars）和<strong>Prometheus</strong>[<a href="#appendix">附录12.19</a>]（github 14.3k stars），这些产品函数报表能力丰富，自带告警模块，但是分布式能力不足，适用于中小规模企业。<strong>Grafana</strong>[<a href="#appendix">附录12.20</a>]（github 19.9k stars）是Metrics报表展示的社区标配。</p><p>社区还有一些通用的健康检查和告警产品，例如<strong>Sensu</strong>[<a href="#appendix">附录12.21</a>]（github 2.7k stars），能够对各种服务（例如spring boot暴露的健康检查端点，时间序列数据库中的metrics，ELK中的错误日志等）定制灵活的健康检查(check)，然后用户可以针对check结果设置灵活的告警通知策略。Sensu在Yelp等公司有落地案例。其它类似产品还有Esty开源的<strong>411</strong>[<a href="#appendix">附录12.22</a>]（github 0.74k星）和Zalando的<strong>ZMon</strong>[<a href="#appendix">附录12.23</a>] (github 0.15k星)，它们是分别在Esty和Zalando落地的产品，但是定制check和告警配置的使用门槛比较高，社区不热，建议有定制自研能力的团队试用。ZMon后台采用KairosDB存储，如果企业已经采用KariosDB作为时间序列数据库，则可以考虑ZMon作为告警通知模块。</p><h2 id="七、服务容错选型"><a href="#七、服务容错选型" class="headerlink" title="七、服务容错选型"></a>七、服务容错选型</h2><p>针对Java技术栈，Netflix的<strong>Hystrix</strong>[<a href="#appendix">附录12.24</a>]（github 12.4k stars）把熔断、隔离、限流和降级等能力封装成组件，任何依赖调用（数据库，服务，缓存）都可以封装在Hystrix Command之内，封装后自动具备容错能力。Hystrix起源于Netflix的弹性工程项目，经过Netflix大规模生产验证，目前是容错组件的社区标准，github上有超12k星。其它语言栈也有类似Hystrix的简化版本组件。</p><p>Hystrix一般需要在应用端或者框架内埋点，有一定的使用门槛。对于采用集中式反向代理（边界和内部）做服务路由的公司，则可以集中在反向代理上做熔断限流，例如采用<strong>nginx</strong>[<a href="#appendix">附录12.25</a>]（github 5.1k stars）或者<strong>Kong</strong>[<a href="#appendix">附录12.7</a>]（github 11.4k stars）这类反向代理，它们都有插件支持灵活的限流容错配置。Zuul网关也可以集成Hystrix实现网关层集中式限流容错。集中式反向代理需要有一定的研发和运维能力，但是可以对限流容错进行集中治理，可以简化客户端。</p><h2 id="八、后台服务选型"><a href="#八、后台服务选型" class="headerlink" title="八、后台服务选型"></a>八、后台服务选型</h2><p>后台服务主要包括消息系统，分布式缓存，分布式数据访问层和任务调度系统。后台服务是一个相对比较成熟的领域，很多开源产品基本可以开箱即用。</p><p><strong>消息系统</strong>，对于日志等可靠性要求不高的场景，则Apache顶级项目<strong>Kafka</strong>[<a href="#appendix">附录12.26</a>]（github 7.2k stars）是社区标配。对于可靠性要求较高的业务场景，kafka其实也是可以胜任，但企业需要根据具体场景，对 Kafka的监控和治理能力进行适当定制完善，Allegro公司开源的<strong>hermes</strong>[<a href="#appendix">附录12.27</a>]（github 0.3k stars）是一个可参考项目，它在Kafka基础上封装了适合业务场景的企业级治理能力。阿里开源的<strong>RocketMQ</strong>[<a href="#appendix">附录12.28</a>]（github 3.5k星）也是一个不错选择，具备更多适用于业务场景的特性，目前也是Apache顶级项目。<strong>RabbitMQ</strong>[<a href="#appendix">附录12.29</a>]（github 3.6k星）是老牌经典的MQ，队列特性和文档都很丰富，性能和分布式能力稍弱，中小规模场景可选。</p><p>对于<strong>缓存治理</strong>，如果倾向于采用客户端直连模式（个人认为缓存直连更简单轻量），则SohuTv开源的<strong>cachecloud</strong>[<a href="#appendix">附录12.30</a>]（github 2.5k stars）是一款不错的Redis缓存治理平台，提供诸如监控统计，一键开启，自动故障转移，在线伸缩，自动化运维等生产级治理能力，另外其文档也比较丰富。如果倾向采用中间层Proxy模式，则Twitter开源的<strong>twemproxy</strong>[<a href="#appendix">附录12.31</a>]（github 7.5k stars）和CodisLab开源的<strong>codis</strong>[<a href="#appendix">附录12.32</a>]（github 6.9k stars）是社区比较热的选项。</p><p>对于<strong>分布式数据访问层</strong>，如果采用Java技术栈，则当当开源的<strong>shardingjdbc</strong>[<a href="#appendix">附录12.33</a>]（github 3.5k stars）是一个不错的选项，分库分表逻辑做在客户端jdbc driver中，客户端直连数据库比较简单轻量，建议中小规模场景采用。如果倾向采用数据库访问中间层proxy模式，则从阿里Cobar演化出来的社区开源分库分表中间件<strong>MyCAT</strong>[<a href="#appendix">附录12.34</a>]（github 3.6k stars）是一个不错选择 。proxy模式运维成本较高，建议中大规模场景，有一定框架自研和运维能力的团队采用。</p><p><strong>任务调度系统</strong>，个人推荐徐雪里开源的<strong>xxl-job</strong>[<a href="#appendix">附录12.35</a>]（github 3.4k stars），部署简单轻量，大部分场景够用。当当开源的<strong>elastic-job</strong>[<a href="#appendix">附录12.36</a>]（github 3.2k stars）也是一个不错选择，相比xxl-job功能更强一些也更复杂。</p><h2 id="九、服务安全选型"><a href="#九、服务安全选型" class="headerlink" title="九、服务安全选型"></a>九、服务安全选型</h2><p>对于微服务安全认证授权机制一块，目前业界虽然有OAuth和OpenID connect等标准协议，但是各家具体实现的做法都不太一样，企业一般有很多特殊的定制需求，整个社区还没有形成通用生产级开箱即用的产品。有一些开源授权服务器产品，比较知名的如<strong>Apereo CAS</strong>[<a href="#appendix">附录12.37</a>]（github 3.6k stars），JBoss开源的<strong>keycloak</strong>[<a href="#appendix">附录12.38</a>]（github 1.9 stars），<strong>spring cloud security</strong>[<a href="#appendix">附录12.39</a>]等，大都是opinionated（一家观点和做法）的产品，同时因支持太多协议造成产品复杂，也缺乏足够灵活性。个人建议基于OAuth和OpenID connect标准，在参考一些开源产品的基础上（例如Mitre开源的<strong>OpenID-Connect-Java-Spring-Server</strong>[<a href="#appendix">附录12.40</a>]，github 0.62k stars），定制自研轻量级授权服务器。Wso2提出了一种微服务安全的参考方案[<a href="#appendix">附录12.45</a>]，建议参考，该方案的关键步骤如下：</p><p><img src="/2018/03/25/20180325/msa_security.png" alt="msa security"></p><ol><li>使用支持OAuth 2.0和OpenID Connect标准协议的授权服务器（个人建议定制自研）；</li><li>使用API网关作为单一访问入口，统一实现安全治理；</li><li>客户在访问微服务之前，先通过授权服务器登录获取access token，然后将access token和请求一起发送到网关；</li><li>网关获取access token，通过授权服务器校验token，同时做token转换获取JWT token。</li><li>网关将JWT Token和请求一起转发到后台微服务；</li><li>JWT中可以存储用户会话信息，该信息可以传递给后台的微服务，也可以在微服务之间传递，用作认证授权等用途；</li><li>每个微服务包含JWT客户端，能够解密JWT并获取其中的用户会话信息。</li><li>整个方案中，access token是一种by reference token，不包含用户信息可以直接暴露在公网上；JWT token是一种by value token，可以包含用户信息但不暴露在公网上。</li></ol><h2 id="十、服务部署平台选型"><a href="#十、服务部署平台选型" class="headerlink" title="十、服务部署平台选型"></a>十、服务部署平台选型</h2><p>容器已经被社区接受为交付微服务的一种理想手段，可以实现不可变（immutable）发布模式。一个轻量级的基于容器的服务部署平台主要包括容器资源调度，发布系统，镜像治理，资源治理和IAM等模块。</p><p><strong>集群资源调度系统</strong>：屏蔽容器细节，将整个集群抽象成容器资源池，支持按需申请和释放容器资源，物理机发生故障时能够实现自动故障迁移(fail over)。目前Google开源的<strong>kubernetes</strong>[<a href="#appendix">附录12.41</a>]，在Google背书和社区的强力推动下，基本已经形成市场领导者地位，github上有31.8k星，社区的活跃度已经远远超过了<strong>mesos</strong>[<a href="#appendix">附录12.42</a>]（github 3.5k stars）和swarm等竞争产品，所以容器资源调度建议首选k8s。当然如果你的团队有足够定制自研能力，想深度把控底层调度算法，也可以基于mesos做定制自研。</p><p><strong>镜像治理</strong>：基于docker registry，封装一些轻量级的治理功能。vmware开源的harbor[<a href="#appendix">附录12.43</a>] (github 3.5k stars)是目前社区比较成熟的企业级产品，在docker registry基础上扩展了权限控制，审计，镜像同步，管理界面等治理能力，可以考虑采用。</p><p><strong>资源治理</strong>：类似于CMDB思路，在容器云环境中，企业仍然需要对应用app，组织org，容器配额和数量等相关信息进行轻量级的治理。目前这块还没有生产级的开源产品，一般企业需要根据自己的场景定制自研。</p><p><strong>发布平台</strong>：面向用户的发布管理控制台，支持发布流程编排。它和其它子系统对接交互，实现基本的应用发布能力，也实现如蓝绿，金丝雀和灰度等高级发布机制。目前这块生产级的开源产品很少，Netflix开源的<strong>spinnaker</strong>[<a href="#appendix">附录12.44</a>]（github 4.2k stars）是一个，但是这个产品比较复杂重量（因为它既要支持适配对接各种CI系统，同时还要适配对接各种公有云和容器云，使得整个系统异常复杂），一般企业建议根据自己的场景定制自研轻量级的解决方案。</p><p><strong>IAM</strong>：是identity &amp; access management的简称，对发布平台各个组件进行身份认证和安全访问控制。社区有不少开源的IAM产品，比较知名的有<strong>Apereo CAS</strong>（github 3.6k stars），JBoss开源的<strong>keycloak（github 1.9 stars）</strong>等。但是这些产品一般都比较复杂重量，很多企业考虑到内部各种系统灵活对接的需求，都会考虑定制自研轻量级的解决方案。</p><p>考虑到服务部署平台目前还没有端到端生产级解决方案，企业一般需要定制集成，下面给出一个可以参考的具备轻量级治理能努力的发布体系：</p><p><img src="/2018/03/25/20180325/deployment_system.png" alt="deployment system"></p><p>简化发布流程如下：</p><ol><li>应用通过CI集成后生成镜像，用户将镜像推到镜像治理中心；</li><li>用户在资产治理中心申请发布，填报应用，发布和配额相关信息，然后等待审批通过；</li><li>发布审批通过，开发人员通过发布控制台发布应用；</li><li>发布系统通过查询资产治理中心获取发布规格信息；</li><li>发布系统向容器云发出启动容器实例指令；</li><li>容器云从镜像治理中心拉取镜像并启动容器；</li><li>容器内服务启动后自注册到服务注册中心，并保持定期心跳；</li><li>用户通过发布系统调用服务注册中心调拨流量，实现蓝绿，金丝雀或灰度发布等机制；</li><li>网关和内部微服务客户端定期同步服务注册中心上的服务路由表，将流量按负载均衡策略分发到新的服务实例上。</li></ol><p>另外，持续交付流水线（CD Pipeline）也是微服务发布重要环节，这块主要和研发流程相关，一般需要企业定制，下面是一个可供参考的流水线模型，在镜像治理中心上封装一些轻量级的治理流程，例如只有通过测试环境测试的镜像才能升级发布到UAT环境，只有通过UAT环境测试的镜像才能升级发布到生产环境，通过在流水线上设置一些质量门，保障应用高质量交付到生产。</p><p><img src="/2018/03/25/20180325/cd.png" alt="cd pipeline"></p><h2 id="十一、写在最后"><a href="#十一、写在最后" class="headerlink" title="十一、写在最后"></a>十一、写在最后</h2><p>注意，本文限于篇幅，对测试和CI等环节没有涉及，但它们同样是构建微服务架构的重要环节，也有众多成熟的开源成熟产品可选。</p><p>技术选型虽然重要，但还只是微服务建设的一小部分工作，选型后的产品要在企业内部真正落地，形成完整的微服务技术栈体系，则后续还有大量集成、定制、治理、运维和推广等工作。</p><p>本文仅限个人经验视角，选型思路仅供参考借鉴。每个企业的具体上下文（业务场景，团队组织，技术架构等）各不相同，每个架构师的背景经验也各不相同，大家要结合实际自己做出选型，没有最好的技术栈，只有相对较合适的技术栈。另外，好的技术选型是相互借鉴甚至PK出来的，欢迎大家讨论，给出自己的微服务2.0技术栈选型意见。</p><h2 id="十二、附录"><a href="#十二、附录" class="headerlink" title="十二、附录"></a><a name="appendix">十二、附录</a></h2><ol><li><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a></li><li><a href="https://github.com/alibaba/dubbo" target="_blank" rel="noopener">Alibaba Dubbo</a></li><li><a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">Google gRPC</a></li><li><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">NetflixOSS Eureka</a></li><li><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">Hashicorp Consul</a></li><li><a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">NetflixOSS Zuul</a></li><li><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">Kong</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">Spring Cloud Config</a></li><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">CTrip Apollo</a></li><li><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">ElasticSearch</a></li><li><a href="https://github.com/Yelp/elastalert" target="_blank" rel="noopener">Yelp Elastalert</a></li><li><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">Dianping CAT</a></li><li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a></li><li><a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Naver Pinpoint</a></li><li><a href="https://github.com/OpenTSDB/opentsdb" target="_blank" rel="noopener">OpenTSDB</a></li><li><a href="https://github.com/kairosdb/kairosdb" target="_blank" rel="noopener">KairosDB</a></li><li><a href="https://github.com/salesforce/Argus" target="_blank" rel="noopener">Argus</a></li><li><a href="https://github.com/influxdata/influxdb" target="_blank" rel="noopener">InfluxDB</a></li><li><a href="https://github.com/prometheus/prometheus" target="_blank" rel="noopener">Prometheus</a></li><li><a href="https://github.com/grafana/grafana" target="_blank" rel="noopener">Grafana</a></li><li><a href="https://github.com/sensu/sensu" target="_blank" rel="noopener">Sensu</a></li><li><a href="https://github.com/etsy/411" target="_blank" rel="noopener">Esty 411</a></li><li><a href="https://github.com/zalando/zmon" target="_blank" rel="noopener">Zalando ZMon</a></li><li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">NetflixOSS Hystrix</a></li><li><a href="https://github.com/nginx/nginx" target="_blank" rel="noopener">Nginx</a></li><li><a href="https://github.com/apache/kafka" target="_blank" rel="noopener">Apache Kafka</a></li><li><a href="https://github.com/allegro/hermes" target="_blank" rel="noopener">Allegro Hermes</a></li><li><a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache Rocketmq</a></li><li><a href="https://github.com/rabbitmq/rabbitmq-server" target="_blank" rel="noopener">Rabbitmq</a></li><li><a href="https://github.com/sohutv/cachecloud" target="_blank" rel="noopener">Sohutv CacheCloud</a></li><li><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twitter twemproxy</a></li><li><a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">CodisLab codis</a></li><li><a href="https://github.com/shardingjdbc/sharding-jdbc" target="_blank" rel="noopener">Dangdang Sharding-jdbc</a></li><li><a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="noopener">MyCAT</a></li><li><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">Xxl-job</a></li><li><a href="https://github.com/elasticjob/elastic-job-lite" target="_blank" rel="noopener">Dangdang elastic-job</a></li><li><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">Apereo CAS</a></li><li><a href="https://github.com/keycloak/keycloak" target="_blank" rel="noopener">JBoss keycloak</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-security" target="_blank" rel="noopener">Spring cloud security</a></li><li><a href="https://github.com/mitreid-connect/OpenID-Connect-Java-Spring-Server" target="_blank" rel="noopener">OpenID-Connect-Java-Spring-Server</a></li><li><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">Google Kubernetes</a></li><li><a href="https://github.com/apache/mesos" target="_blank" rel="noopener">Apache Mesos</a></li><li><a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">Vmware Harbor</a></li><li><a href="https://github.com/spinnaker/spinnaker" target="_blank" rel="noopener">Netflix Spinnaker</a></li><li><a href="https://wso2.com/whitepapers/microservices-in-practice-key-architectural-concepts-of-an-msa/" target="_blank" rel="noopener">Microservices in Practice – Key Architecture Concepts of an MSA</a></li><li><a href="http://servicecomb.incubator.apache.org/assets/slides/20170619/MSAPrinciple&amp;EcoSystem.pdf" target="_blank" rel="noopener">微服务的设计与生态系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;2014年可以认为是微服务1.0的元年，当年有几个标志性事件，一是Martin Fowler在其博客上发表了“Microservices”一文，正式提出微服务架构风格；二是Netflix微服务架构经过多年大规模生产验证，最终抽象落地形成一整套开源的微服务基础组件，统称NetflixOSS，Netflix的成功经验开始被业界认可并推崇；三是Pivotal将NetflixOSS开源微服务组件集成到其Spring体系，推出Spring Cloud微服务开发技术栈。&lt;/p&gt;
&lt;p&gt;一晃三年过去，微服务技术生态又发生了巨大变化，容器，PaaS，Cloud Native，gRPC，ServiceMesh，Serverless等新技术新理念你方唱罢我登场，不知不觉我们又来到了微服务2.0时代。基于近年在微服务基础架构方面的实战经验和平时的学习积累，我想总结并提出一些构建微服务2.0技术栈的选型思路，供各位在一线实战的架构师、工程师参考借鉴。对于一些暂时还没有成熟开源产品的微服务支撑模块，我也会给出一些定制自研的设计思路。&lt;/p&gt;
    
    </summary>
    
      <category term="技术管理" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="技术选型" scheme="http://techblog.ppdai.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
      <category term="微服务" scheme="http://techblog.ppdai.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>现代发布技术的原理和实践</title>
    <link href="http://techblog.ppdai.com/2018/03/24/20180324/"/>
    <id>http://techblog.ppdai.com/2018/03/24/20180324/</id>
    <published>2018-03-24T10:46:34.000Z</published>
    <updated>2018-03-27T08:02:36.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>根据2017年的DevOps发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。</p><p>作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。</p><a id="more"></a><h2 id="二、单服务器组发布"><a href="#二、单服务器组发布" class="headerlink" title="二、单服务器组发布"></a>二、单服务器组发布</h2><p>先解释下单服务器组的概念，早先我们机器资源比较紧张，不像现在云计算和虚拟化（包括容器技术）这么发达，所以应用机器基本是预先静态分配好的（一般由运维负责分配），原来应用A住在这n台机器上，那么下次升级发布的应用A也住在这n台机器上，所以称为单服务器组发布方式。</p><h3 id="2-1-蛮力发布"><a href="#2-1-蛮力发布" class="headerlink" title="2.1 蛮力发布"></a>2.1 蛮力发布</h3><p>如下图所示，这种发布方式比较简单粗暴，有点像我们传统的软件升级方式，主要靠手工完成，先将老版本V1全部下掉，再将新版本发到机器上去。这种方式会引入服务中断（停机），在开发测试环境是可行的，但对于生产环境发布，其会直接影响用户的使用体验，这种方式一般是不建议的。</p><p><img src="/2018/03/24/20180324/reckless_1.png" alt="reckless before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/2018/03/24/20180324/reckless_2.png" alt="reckless after"></p><center style="margin: -20px 0 20px">发布后</center><h4 id="优势和适用场合"><a href="#优势和适用场合" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>简单成本低</li></ul><p><strong>不足：</strong></p><ul><li>服务中断用户受影响，出了问题回退也慢</li></ul><p><strong>适用场合：</strong></p><ul><li>开发测试环境</li><li>非关键应用（用户影响面小）</li><li>初创公司什么都缺，找夜深人静用户访问量小的时间干</li></ul><h4 id="流量模式"><a href="#流量模式" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/reckless_traffic.png" alt="reckless traffic model"></p><p>蛮力发布会引入服务中断时间，图片来自<a href="#appendix">附录7.1</a></p><h3 id="2-2-金丝雀发布（单服务器组）"><a href="#2-2-金丝雀发布（单服务器组）" class="headerlink" title="2.2 金丝雀发布（单服务器组）"></a>2.2 金丝雀发布（单服务器组）</h3><p>在蛮力发布基础上的一种简单改进发布方式，目前仍然是不少成长型技术组织的主流发布方式。单服务器组下的金丝雀发布的简化步骤如下图所示：</p><p><img src="/2018/03/24/20180324/canary_1group_1.png" alt="canary one group before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/2018/03/24/20180324/canary_1group_2.png" alt="canary one group first"></p><center style="margin: -20px 0 20px">先发一台金丝雀</center><p><img src="/2018/03/24/20180324/canary_1group_3.png" alt="canary one group after"></p><center style="margin: -20px 0 20px">全部发完</center><h4 id="实践要点"><a href="#实践要点" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>金丝雀发布一般先发1台，或者一个小比例，例如2%的服务器，主要做流量验证用，也称为金丝雀(Canary)测试（国内常称灰度测试）。以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据。</li><li>如果金丝测试通过，则把剩余的V1版本全部升级为V2版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。</li></ol><p><img src="/2018/03/24/20180324/canary.png" alt="canary"></p><center style="margin: -20px 0 20px">金丝雀</center><h4 id="优势和适用场合-1"><a href="#优势和适用场合-1" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>用户体验影响小，金丝雀发布过程出现问题只影响少量用户</li></ul><p><strong>不足：</strong></p><ul><li>发布自动化程度不够，发布期间可引发服务中断</li></ul><p><strong>适用场合：</strong></p><ul><li>对新版本功能或性能缺乏足够信心</li><li>用户体验要求较高的网站业务场景</li><li>缺乏足够的自动化发布工具研发能力</li></ul><h4 id="流量模式-1"><a href="#流量模式-1" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/canary_1group_traffic.png" alt="canary one group traffic"></p><p>少量金丝雀先接受流量，再全量发布，图片来自<a href="#appendix">附录7.1</a></p><h3 id="2-3-滚动式发布（单服务器组）"><a href="#2-3-滚动式发布（单服务器组）" class="headerlink" title="2.3 滚动式发布（单服务器组）"></a>2.3 滚动式发布（单服务器组）</h3><p>在金丝雀发布基础上的进一步优化改进，是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式。单服务器组下的滚动发布的简化步骤如下图所示：</p><p><img src="/2018/03/24/20180324/rolling_update_1group_1.png" alt="rolling update one group before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/2018/03/24/20180324/rolling_update_1group_2.png" alt="rolling update one group first"></p><center style="margin: -20px 0 20px">发布中，先发一台金丝雀</center><p><img src="/2018/03/24/20180324/rolling_update_1group_3.png" alt="rolling update one group middle"></p><center style="margin: -20px 0 20px">发布中，再发若干台</center><p><img src="/2018/03/24/20180324/rolling_update_1group_4.png" alt="rolling update one group after"></p><center style="margin: -20px 0 20px">直到全部发完</center><h4 id="实践要点-1"><a href="#实践要点-1" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>滚动式发布一般先发1台，或者一个小比例，如2%服务器，主要做流量验证用，类似金丝雀(Canary)测试。</li><li>滚动式发布需要比较复杂的发布工具和智能LB，支持平滑的版本替换和流量拉入拉出。</li><li>每次发布时，先将老版本V1流量从LB上摘除，然后清除老版本，发新版本V2，再将LB流量接入新版本。这样可以尽量保证用户体验不受影响。</li><li>一次滚动式发布一般由若干个发布批次组成，每批的数量一般是可以配置的（可以通过发布模板定义）。例如第一批1台（金丝雀），第二批10%，第三批50%，第四批100%。每个批次之间留观察间隔，通过手工验证或监控反馈确保没有问题再发下一批次，所以总体上滚动式发布过程是比较缓慢的(其中金丝雀的时间一般会比后续批次更长，比如金丝雀10分钟，后续间隔2分钟)。</li><li>回退是发布的逆过程，将新版本流量从LB上摘除，清除新版本，发老版本，再将LB流量接入老版本。和发布过程一样，回退过程一般也比较慢的。</li><li>滚动式发布国外术语通常叫Rolling Update Deployment。</li></ol><h4 id="优势和适用场合-2"><a href="#优势和适用场合-2" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>用户体验影响小，体验较平滑</li></ul><p><strong>不足：</strong></p><ul><li>发布和回退时间比较缓慢</li><li>发布工具比较复杂，LB需要平滑的流量摘除和拉入能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>有一定的复杂发布工具研发能力；</li></ul><h4 id="流量模式-2"><a href="#流量模式-2" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/rolling_update_traffic.png" alt="rolling udpate one group traffic"></p><p>滚动式发布，流量平滑过渡，图片来自<a href="#appendix">附录7.1</a></p><h2 id="三、双服务器组发布"><a href="#三、双服务器组发布" class="headerlink" title="三、双服务器组发布"></a>三、双服务器组发布</h2><p>随着云计算和虚拟化技术的成熟，特别是容器等轻量级虚拟化技术的引入，计算资源受限和申请缓慢问题已经逐步解决，可以做到弹性按需分配。为一次发布分配两组服务器，一组运行现有的V1老版本，一组运行待上线的V2新版本，再通过LB切换流量方式完成发布，这就是所谓的双服务器组发布方式。</p><h3 id="3-1-蓝绿发布（双服务器组）"><a href="#3-1-蓝绿发布（双服务器组）" class="headerlink" title="3.1 蓝绿发布（双服务器组）"></a>3.1 蓝绿发布（双服务器组）</h3><p>蓝绿发布仅适用于双服务器组发布，可以认为是对蛮力发布的一种简单优化发布方式。简化过程如下图所示：</p><p><img src="/2018/03/24/20180324/blue_green_2groups_before.png" alt="blue green two groups before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/2018/03/24/20180324/blue_green_2groups_after.png" alt="blue green two groups after"></p><center style="margin: -20px 0 20px">发布后</center><h4 id="实践要点-2"><a href="#实践要点-2" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>V1版本称为蓝组，V2版本称为绿组，发布时通过LB一次性将流量从蓝组直接切换到绿组，不经过金丝雀和滚动发布，蓝绿发布由此得名；</li><li>出现问题回退也很直接，通过LB直接将流量切回蓝组。</li><li>发布初步成功后，蓝组机器一般不直接回收，而是留一个待观察期，视具体情况观察期的时间可长可短，观察期过后确认发布无问题，则可以回收蓝组机器。</li></ol><h4 id="优势和适用场合-3"><a href="#优势和适用场合-3" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果V2版本有问题，则对用户体验有直接影响；</li><li>需要两倍机器资源；</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>机器资源有富余或者可以按需分配（AWS云，或自建容器云）</li><li>暂不具备复杂滚动发布工具研发能力；</li></ul><h4 id="流量模式-3"><a href="#流量模式-3" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/blue_green_2groups_traffic.png" alt="blue green two groups traffic"></p><p>蓝绿发布一次完成流程切换，图片来自<a href="#appendix">附录7.1</a></p><h3 id="3-2-金丝雀发布（双服务器组）"><a href="#3-2-金丝雀发布（双服务器组）" class="headerlink" title="3.2 金丝雀发布（双服务器组）"></a>3.2 金丝雀发布（双服务器组）</h3><p>对蓝绿部署的一种简单优化，发布时先从绿组拉入1台金丝雀，待金丝雀验证通过再发全量。对比蓝绿发布，该发布方式的优势是有一个生产流量的金丝雀验证过程，可以减轻V2可能有问题的风险和影响面。简化发布过程如下图所示：</p><p><img src="/2018/03/24/20180324/canary_2groups_1.png" alt="canary two groups before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/2018/03/24/20180324/canary_2groups_2.png" alt="canary two groups middle"></p><center style="margin: -20px 0 20px">发布中，先发一台金丝雀</center><p><img src="/2018/03/24/20180324/canary_2groups_3.png" alt="canary two groups after"></p><center style="margin: -20px 0 20px">全量发布</center><h3 id="3-3-滚动式发布（双服务器组）"><a href="#3-3-滚动式发布（双服务器组）" class="headerlink" title="3.3 滚动式发布（双服务器组）"></a>3.3 滚动式发布（双服务器组）</h3><p>滚动式发布是对上面的蓝绿和金丝雀发布的进一步优化，按批次增量滚动发布，提供更平滑的用户体验。</p><p><img src="/2018/03/24/20180324/rolling_update_2groups_1.png" alt="rolling update two groups before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/2018/03/24/20180324/rolling_update_2groups_2.png" alt="rolling update two groups first"></p><center style="margin: -20px 0 20px">发布中，先发一台金丝雀</center><p><img src="/2018/03/24/20180324/rolling_update_2groups_3.png" alt="rolling update two groups middle"></p><center style="margin: -20px 0 20px">发布中，再发若干台</center><p><img src="/2018/03/24/20180324/rolling_update_2groups_4.png" alt="rolling update two groups after"></p><center style="margin: -20px 0 20px">直到全部发完</center><h3 id="实践要点-3"><a href="#实践要点-3" class="headerlink" title="实践要点"></a>实践要点</h3><ol><li>发布前先申请一批新服务器，数量一般和V1版本相同，将V2版本应用发布到新服务器上。例如如果在AWS云上，则可以直接调用API申请一批新VM，如果用容器云k8s，则可以直接启动一批新容器（使用V2版本容器镜像）。</li><li>一般会先通过LB拉入1台V2版本的机器，这台机器也相当于金丝雀，用于流量验证。</li><li>逐步按批次完成发布，每批只需要通过LB拉入V2版本，再拉出对应数量的V1版本。批次之间留有观察间隔，通过手工或监控反馈确保没有问题再继续发布。</li><li>发布有问题回退很快，直接通过LB将流量切回V1即可。</li><li>完成发布后，一般V1版本要保留观察以备万一，比如留1天，1天后没有问题则回收V1机器资源。</li></ol><h4 id="优势和适用场合-4"><a href="#优势和适用场合-4" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>升级切换和回退（rollback）速度比单服务器组滚动发布要快，LB切流量即可；</li></ul><p><strong>不足：</strong></p><ul><li>需要两倍机器资源；</li><li>发布工具比较复杂，LB需要流量切换能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>机器资源有富余或者可以按需分配（AWS云，或自建容器云）</li><li>有一定的发布工具研发能力；</li></ul><h4 id="流量模式-4"><a href="#流量模式-4" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/rolling_update_traffic.png" alt="rolling upodate two groups traffic"></p><p>滚动式发布，流量平滑过渡，图片来自<a href="#appendix">附录7.1</a></p><h2 id="四、其它发布方式"><a href="#四、其它发布方式" class="headerlink" title="四、其它发布方式"></a>四、其它发布方式</h2><p>上述都是偏传统的发布方式，能覆盖大部分应用发布场景。针对一些关键新功能的上线发布，或者一些特定的场景，还有一些特殊的发布方式。</p><h3 id="4-1-功能开关发布"><a href="#4-1-功能开关发布" class="headerlink" title="4.1 功能开关发布"></a>4.1 功能开关发布</h3><p>利用代码中的功能开关（Feature Flag/Toggle/Switch）来控制发布逻辑，一般不需要复杂的发布工具和智能LB配合，是一种相对比较低成本和简单的发布方式。这种方式也是支持现代DevOps理念，研发人员可以灵活定制和自助完成的发布方式。功能开关的原理如下图所示：</p><p><img src="/2018/03/24/20180324/feature_flag_deployment.png" alt="feature flag deployment"></p><p>功能开关发布，图片来自<a href="#appendix">附录7.2</a></p><h4 id="实践要点-4"><a href="#实践要点-4" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>功能开关发布需要一个配置中心或者开关中心这样的服务支持，例如携程的Apollo配置中心<a href="#appendix">附录7.3</a>，或者开源的FF4J<a href="#appendix">附录7.4</a>，这些都支持开关发布，业界还有专门的功能开关SaaS服务，例如LaunchDarkly<a href="#appendix">附录7.5</a>。通过配置中心，运维或研发人员可以在运行期动态配置功能开关的值。当然，功能开关发布只是配置中心的一种使用场景，配置中心还能支持其它很多动态配置场景。</li><li>功能开关服务一般提供客户端SDK，方便开发人员集成。在运行期，客户端SDK会同步最新的开关值，技术实现有推方式(push)，也有拉方式(pull)，或者推拉结合方式。</li><li>新功能（V2 new feature）和老功能（V1 old feature）住在同一套代码中，新功能隐藏在开关后面，如果开关没有打开，则走老代码逻辑，如果开关打开，则走新代码逻辑。技术实现上可以理解为一个简单的if/else逻辑。</li><li>应用上线后，开关先不打开，然后运维或研发人员通过开关中心打开新功能，经过流量验证新功能没有问题，则发布完成；如果有问题，则随时可以通过开关中心切回老功能逻辑。</li></ol><h4 id="优势和适用场合-5"><a href="#优势和适用场合-5" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li><li>相对于复杂的发布工具，实施比较简单，成本相对低廉</li><li>研发能够灵活定制发布逻辑，支持DevOps自助发布</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果V2版本有问题，则对用户体验有直接影响；</li><li>对代码有侵入，代码逻辑会变复杂，需要定期清理老版本逻辑，维护成本变高</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>已有配置中心或开关中心服务</li><li>暂不具备研发复杂发布工具能力；</li></ul><h4 id="流量模式-5"><a href="#流量模式-5" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/blue_green_2groups_traffic.png" alt="feature flag traffic"></p><p>通过功能开关一次完成流量切换，图片来自<a href="#appendix">附录7.1</a></p><h3 id="4-2-A-B测试"><a href="#4-2-A-B测试" class="headerlink" title="4.2 A/B测试"></a>4.2 A/B测试</h3><p>A/B测试<a href="#appendix">附录7.10</a>原来主要用于产品功能的比对测试，收集用户反馈和对比数据做产品功能设计的决策。实际上，A/B测试也可以作为一种新功能发布技术。下图展示基于LB实现的一种A/B测试发布。</p><p><img src="/2018/03/24/20180324/ab_testing_deployment.png" alt="a/b testing deployment"></p><h4 id="实践要点-5"><a href="#实践要点-5" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>上图中，原来PC端和手机端都访问老版本V1服务（也称A组或控制组），当V2新版本（也称B组或实验组）发布以后，为了验证V2的功能正确性，同时也为了避免V2有问题时影响所有用户，先通过LB将手机端的流量切换到V2版本，经过一段时间的A/B比对测试和观察（主要通过用户和监控反馈），确保V2正常，则通过LB将全部流量切换到V2。</li><li>基于LB方式实现A/B测试，LB需要能够通过某种条件做流量路由，例如通过client ip，设备类型，浏览器类型，甚至是定制的http header或查询字符串。</li><li>高级的A/B测试需要专门的平台支撑，wasabi<a href="#appendix">附录7.6</a>就是intuit开源的一个支持高级A/B测试的平台，这类平台可以细粒度到针对某类用户做A/B测试，例如针对某个地区的用户，某个年龄段的用户，公司内部用户等等。举了例子，假设一个关键业务的新功能上线，为了降低风险采用A/B测试，可以做到先只让公司内部员工能访问到新功能，待新功能验证过，再全量放开给外部用户使用。</li><li>功能开关和A/B测试有点相似，但功能开关一般是无状态和全量的，无法做到针对某类特定用户进行测试，而A/B测试一般是有状态的，能够跟踪事务和用户级别的状态，可以实现针对某类特定用户进行测试。</li></ol><h4 id="优势和适用场合-6"><a href="#优势和适用场合-6" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>可以使用生产流量测试；</li><li>可以做到针对某类特定目标用户进行测试；</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度相对高，有一定技术门槛</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定的A/B测试平台研发能力</li></ul><h4 id="流量模式-6"><a href="#流量模式-6" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/ab_testing_traffic.png" alt="a/b testing traffic"></p><p>针对某类目标用户进行A/B测试，图片来自<a href="#appendix">附录7.1</a></p><h3 id="4-3-影子测试"><a href="#4-3-影子测试" class="headerlink" title="4.3 影子测试"></a>4.3 影子测试</h3><p>对于一些涉及核心业务的遗留系统的升级改造，为了确保万无一失，有一种称为影子测试的大招，采用比较复杂的流量复制、回放和比对技术实现。下面是影子测试的一个样例架构图，</p><p><img src="/2018/03/24/20180324/shadow_testing.png" alt="shadow testing"></p><h4 id="实践要点-6"><a href="#实践要点-6" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>目标实现老的legacy服务迁移升级到新的experimental服务。</li><li>测试开始前，需要在测试环境部署一份legacy服务和experimental服务，同时将生产数据库复制两份到测试环境。同时需要将生产请求日志收集起来，一般可以通过kafka队列收集，然后通过类似goreplay<a href="#appendix">附录7.8</a>这样的工具，消费kafka里头的请求日志，复制回放，将请求分发到legacy服务和experimental服务，收到响应后进行比对，如果所有响应比对成功，则可以认为legacy服务和experimental服务在功能逻辑上是等价的；如果有响应比对失败，则认为两者在功能逻辑上不等价，需要修复experimental并重新进行影子测试，直到全部比对成功。根据系统复杂度和关键性不同，比对测试时间短的可能需要几周，长的可达半年之久。</li><li>影子测试因为旁路在独立测试环境中进行，可以对生产流量完全无影响。</li><li>影子测试一般适用于遗留系统的等价重构迁移，例如.net转java，或者sqlserver数据库升级为mysql数据库，且外部依赖不能太多，否则需要开发很多mock，测试部署成本会很高，且比对测试更加复杂和不稳定。</li><li>当当网有一个比较成功的交易系统.net转java迁移项目<a href="#appendix">附录7.9</a>，采用了影子测试技术，值得参考借鉴。</li></ol><h4 id="优势和适用场合-7"><a href="#优势和适用场合-7" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h4><p><strong>优势：</strong></p><ul><li>对生产用户体验完全无影响</li><li>可以使用生产真实流量进行测试（复制比对）</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度很高，技术门槛高，数据库的导出复制是难点</li><li>外部依赖不能太多，否则测试部署成本很高，且比对测试更加复杂和不稳定</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定影子测试平台研发能力，包括流量复制、数据库导出复制和分发比对系统。</li></ul><h4 id="流量模式-7"><a href="#流量模式-7" class="headerlink" title="流量模式"></a>流量模式</h4><p><img src="/2018/03/24/20180324/shadow_testing_traffic.png" alt="shadow testing traffic"></p><p>影子测试对生产流量无影响，图片来自<a href="#appendix">附录7.1</a></p><h2 id="五、比较"><a href="#五、比较" class="headerlink" title="五、比较"></a>五、比较</h2><p>下表对各种发布策略，从各个维度进行综合比较，供参考：</p><p><img src="/2018/03/24/20180324/comparision.png" alt="comparision"></p><h2 id="六、结论和建议"><a href="#六、结论和建议" class="headerlink" title="六、结论和建议"></a>六、结论和建议</h2><p>下面是对发布策略的一些选型建议，供不同阶段公司参考：</p><ol><li>蛮力发布一般是不建议采用的，除非是开发测试环境，用户体验不敏感的非关键应用，或者是创业期什么都缺时候的无奈之举。</li><li>如果暂时还不具备研发较复杂的滚动发布工具和配套智能LB，则功能开关是一种不错的轻量级发布技术，投入相对较小的成本，可以让研发人员灵活定制发布逻辑。</li><li>金丝雀发布通过少量新版本服务器接收生产流量的方式去验证新版本，可以显著降低风险。金丝雀发布适用于大部分场景，一般成长型公司就可以采用。</li><li>对于达到一定业务体量的公司，考虑到用户体验对业务的关键性，则需要投入研发资源开发支持滚动式发布的工具和配套的智能LB，实现自动化和零停机的发布。滚动式发布一般和金丝雀发布配合，先发一台金丝雀去验证流量，再按批次增量发布。</li><li>随着轻量级虚拟化（例如容器）的普及，双服务器组发布方式具有更快的发布和回退速度，是值得投入的高级发布技术。蓝绿部署仅适用于双服务器组，滚动式发布既可以在单服务器组上实现，也可以在双服务器组上实现。</li><li>对于涉及关键核心业务的新功能上线，采用A/B测试，可以显著降低发布风险，A/B测试是唯一一种支持针对特定用户组进行生产测试的高级发布技术。当然A/B测试的投入不低，建议有一定研发能力的组织采用。</li><li>对于关键核心业务的迁移重构，为确保万无一失，最后的一个大招是影子测试，影子测试对生产流量和用户完全无影响。当然这个大招的投入成本和门槛都高，建议有足够业务体量和研发能力的组织投入。</li><li>上述的各种发布策略并不是非此即彼的，一个公司常常会综合采用多种发布技术作为互补，实现灵活的发布能力。例如主流的发布手段是金丝雀+滚动式发布，某些业务线可能根据业务场景需要采用功能开关发布，还有一些业务线则可能采用高级的A/B测试发布手段。</li></ol><h2 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a><a name="appendix">七、附录</a></h2><ol><li><a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">k8s deployment strategies</a></li><li><a href="https://opensource.com/article/18/2/feature-flags-ring-deployment-model" target="_blank" rel="noopener">Deploying new releases: Feature flags or rings?</a></li><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">携程Apollo配置中心</a></li><li><a href="http://www.ff4j.org/" target="_blank" rel="noopener">Feature Flag for Java</a></li><li><a href="https://launchdarkly.com/" target="_blank" rel="noopener">LaunchDarkly ~ Feature Flag as a Service</a></li><li><a href="https://github.com/intuit/wasabi" target="_blank" rel="noopener">Wasabi高级A/B测试平台</a></li><li><a href="https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/" target="_blank" rel="noopener">使用goreplay实现遗留系统升级</a></li><li><a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">Goreplay</a></li><li><a href="http://blog.shurenyun.com/untitled-9/" target="_blank" rel="noopener">9.    华丽蜕变 – 当当网交易系统重构</a></li><li><a href="https://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="noopener">A/B Testing</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;根据2017年的DevOps发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。&lt;/p&gt;
&lt;p&gt;作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="微服务" scheme="http://techblog.ppdai.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="devops" scheme="http://techblog.ppdai.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>第一届技术沙龙精彩回顾</title>
    <link href="http://techblog.ppdai.com/2018/01/16/20180116/"/>
    <id>http://techblog.ppdai.com/2018/01/16/20180116/</id>
    <published>2018-01-16T06:44:30.000Z</published>
    <updated>2018-03-27T03:08:12.396Z</updated>
    
    <content type="html"><![CDATA[<p>1月13日，第一届“拍拍贷技术沙龙”暨《亿级流量网站基础架构》沙龙，在拍拍贷和大家见面了。这次技术沙龙由拍拍贷基础框架部主办，邀请了拍拍贷基础框架部总监杨波、《RabbitMQ实战指南》作者朱忠华、点融网资深架构师刘石明、饿了么框架工具部高级研发经理黄杰四位业内大咖给大家分享了基础架构方面的经验和思考。</p><a id="more"></a><p>首先为大家带来分享的是拍拍贷基础框架部的总监杨波，演讲题目是《拍拍贷贷基础架构的演进之路》。</p><p><img src="/2018/01/16/20180116/1.jpg" alt="image"></p><p>对一个拥有10年发展历史的拍拍贷公司，在过去的一年经历了巨大的技术挑战和升级，杨波带来了其对拍拍贷公司业务和技术背景的思考，及其对未来几年内整个公司技术架构的发展规划，整个分享内容包括如下五个部分：</p><ul><li>业务和技术背景</li><li>2017技术挑战和升级</li><li>新的挑战和思考</li><li>2018技术架构和规划</li><li>团队和文化</li></ul><p>在分享中，杨波详细为大家介绍了在2017年拍拍贷基础框架所面临的挑战，整个基础框架团队怎样在一年内一方面抗住业务压力，一方面快速创新，逐步打造好一个相对完整的基础架构产品生态，一分耕耘，一分收获，在新的2018年，站在新的起点上，杨波对2018年面临的新挑战做了深入的思考，对2018年的技术规划升级提出了四个关键字：“标准化”、“平台化”、“赋能创新”、“闭环反馈”，分别对研发的核心产品进行了介绍和描述，提出了打造基础架构体系2.0版本，这是新的一年，拍拍贷基础框架团队在应对新挑战所肩负的责任。</p><p><img src="/2018/01/16/20180116/2.jpg" alt="image"></p><p><img src="/2018/01/16/20180116/3.jpg" alt="image"></p><p>第二场是朱忠华给大家带来的《RabbitMQ大型电商网站实践》，演讲者朱忠华对RabbitMQ和Kafka有深入的研究，其著有《RabbitMQ实战指南》。</p><p><img src="/2018/01/16/20180116/4.jpg" alt="image"></p><p>消息中间件作为目前分布式系统架构的核心之一，有着举足轻重的地位。起源于金融系统的RabbitMQ作为当前流行的一款消息中间件，素以消息可靠和功能多样性著称。朱忠华围绕着RabbitMQ在大型电商网站使用过程中的一些注意要点、优化手段以及解决方案，比如：消息堆积、网络分区等，做了深入浅出的讲解。</p><p>整个分享主要分为四个部分：</p><ul><li>RabbitMQ简介</li><li>性能优化</li><li>消息堆积应对</li><li>故障处理</li></ul><p>更多详细内容见PPT。</p><p><img src="/2018/01/16/20180116/5.jpg" alt="image"></p><p><img src="/2018/01/16/20180116/6.jpg" alt="image"></p><p>在中场茶歇时间，同学们分享精美小吃、水果，大家面对面也不时地进行技术交流，有着共同的话题，一旦打开话匣子，总是有讲不完的事。</p><p><img src="/2018/01/16/20180116/7.jpg" alt="image"></p><p>第三场是由来自点融网资深架构师刘石明，为大家带来题为《gRpc微服务框架及分布式事务》的分享。</p><p>整个分享分为四个部分：</p><ul><li>Saluki框架概述</li><li>Saluki框架特性</li><li>Dts分布式事务概述</li><li>Dts分布式事务特性</li></ul><p>为大家详细介绍了基于gRpc的服务化框架Saluki的设计理念、详细特性，以及基于两阶段提交的DTS分布式事务的理念、实践经验等。</p><p><img src="/2018/01/16/20180116/8.jpg" alt="image"></p><p><img src="/2018/01/16/20180116/9.jpg" alt="image"></p><p><img src="/2018/01/16/20180116/10.jpg" alt="image"></p><p>第四场由饿了么框架工具部高级研发经理黄杰，为大家带来题为《全链路监控那些事》的分享，分享主要分为五个部分：</p><ul><li>介绍</li><li>整体架构</li><li>计算框架</li><li>存储方案</li><li>Demo</li></ul><p>详细为大家分享了饿了么内部全链路监控体系的应用场景和需求，架构设计，计算框架，存储方面的各种探索和思考。</p><p><img src="/2018/01/16/20180116/11.jpg" alt="image"></p><p><img src="/2018/01/16/20180116/12.jpg" alt="image"></p><p><img src="/2018/01/16/20180116/13.jpg" alt="image"></p><p>在大咖们分享后的问答阶段，同学们和大咖热烈交互，几次因为时间关系不得不转入线下沟通。</p><p><img src="/2018/01/16/20180116/14.jpg" alt="image"></p><p>本次活动的互动奖品是由拍拍贷资深架构师刘璟宇和蚂蚁金服、新浪微博、京东等一线专家合著的《深入分布式缓存》一书，深受到场同学和嘉宾的欢迎：</p><p><img src="/2018/01/16/20180116/15.jpg" alt="image"></p><p>两场抽书环节，各位同学专注的表情：</p><p><img src="/2018/01/16/20180116/16.jpg" alt="image"></p><p>获赠图书同学和作者合影时欢乐的氛围：</p><p><img src="/2018/01/16/20180116/17.jpg" alt="image"></p><p>最后为大家奉上各位嘉宾分享的PPT：<br><a href="https://github.com/ppdai/salon/tree/master/201801" target="_blank" rel="noopener">https://github.com/ppdai/salon/tree/master/201801</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1月13日，第一届“拍拍贷技术沙龙”暨《亿级流量网站基础架构》沙龙，在拍拍贷和大家见面了。这次技术沙龙由拍拍贷基础框架部主办，邀请了拍拍贷基础框架部总监杨波、《RabbitMQ实战指南》作者朱忠华、点融网资深架构师刘石明、饿了么框架工具部高级研发经理黄杰四位业内大咖给大家分享了基础架构方面的经验和思考。&lt;/p&gt;
    
    </summary>
    
      <category term="技术沙龙" scheme="http://techblog.ppdai.com/categories/%E6%8A%80%E6%9C%AF%E6%B2%99%E9%BE%99/"/>
    
    
      <category term="基础架构" scheme="http://techblog.ppdai.com/tags/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
      <category term="RabbitMQ" scheme="http://techblog.ppdai.com/tags/RabbitMQ/"/>
    
      <category term="gRpc" scheme="http://techblog.ppdai.com/tags/gRpc/"/>
    
      <category term="监控" scheme="http://techblog.ppdai.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
</feed>
